---
import '../styles/globals.css';
import { getLocale, baseLocale } from '../paraglide/runtime.js';
import * as m from '../paraglide/messages.js';
import { ViewTransitions } from 'astro:transitions';
import Loading from '../components/Loading.astro';
import { siteConfig, generateMetadata } from '../config/metadata.ts';

interface Props {
	title?: string;
	description?: string;
	lang?: string;
	ogImage?: string;
	type?: 'website' | 'article';
	canonical?: string;
	noindex?: boolean;
}

const {
	title = siteConfig.pages.home.title,
	description = siteConfig.description,
	lang,
	ogImage,
	type = 'website',
	canonical,
	noindex = false
} = Astro.props;

// Force English as default if no specific language is set
const siteLang = lang || baseLocale;

// Generate metadata with proper SEO tags
const metadata = generateMetadata({
	title,
	description,
	path: Astro.url.pathname,
	ogImage,
	type
});

// Centralized authentication state
const user = Astro.locals.user;
const isAuthenticated = !!user;
---

<!doctype html>
<html lang={siteLang}>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<!-- Favicons -->
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="icon" type="image/x-icon" href="/favicon.ico" />
		<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png" />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
		<link rel="manifest" href="/site.webmanifest" />

		<meta name="generator" content={Astro.generator} />

		<!-- Primary Meta Tags -->
		<title>{metadata.title}</title>
		<meta name="title" content={metadata.title} />
		<meta name="description" content={metadata.description} />
		<link rel="canonical" href={canonical || metadata.canonical} />
		{noindex && <meta name="robots" content="noindex, nofollow" />}

		<!-- Open Graph / Facebook -->
		<meta property="og:type" content={metadata.openGraph.type} />
		<meta property="og:url" content={metadata.openGraph.url} />
		<meta property="og:title" content={metadata.openGraph.title} />
		<meta property="og:description" content={metadata.openGraph.description} />
		<meta property="og:image" content={metadata.openGraph.image} />
		<meta property="og:site_name" content={metadata.openGraph.siteName} />
		{metadata.openGraph.publishedTime && <meta property="article:published_time" content={metadata.openGraph.publishedTime} />}
		{metadata.openGraph.modifiedTime && <meta property="article:modified_time" content={metadata.openGraph.modifiedTime} />}

		<!-- Twitter -->
		<meta property="twitter:card" content={metadata.twitter.card} />
		<meta property="twitter:url" content={metadata.openGraph.url} />
		<meta property="twitter:title" content={metadata.twitter.title} />
		<meta property="twitter:description" content={metadata.twitter.description} />
		<meta property="twitter:image" content={metadata.twitter.image} />
		{siteConfig.twitter && <meta property="twitter:site" content={siteConfig.twitter} />}

		<!-- Structured Data for Google -->
		<script type="application/ld+json">
		{
			"@context": "https://schema.org",
			"@type": "Organization",
			"name": "Wavmap",
			"url": "https://wavmap.org",
			"logo": "https://wavmap.org/og-image.png",
			"description": "Discover artists from the underground music community around the world",
			"sameAs": [
				"https://twitter.com/wavmap"
			]
		}
		</script>

		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
	</head>
	<body class="min-h-screen bg-gray-50 font-sans antialiased">
		<slot user={user} isAuthenticated={isAuthenticated} />

		<!-- Auth Interceptor - G√®re automatiquement le refresh des tokens -->
		<script>
			// Auth Interceptor - G√®re automatiquement le refresh des tokens
			class AuthInterceptor {
			  constructor() {
			    this.isRefreshing = false;
			    this.failedRequests = [];
			    this.setupInterceptor();
			  }

			  setupInterceptor() {
			    // Intercepter les fetch requests pour g√©rer les 401 automatiquement
			    const originalFetch = window.fetch;

			    window.fetch = async (url, options = {}) => {
			      try {
			        const response = await originalFetch(url, options);

			        // Only intercept our own API calls, not external services or auth endpoints
			        const shouldIntercept = response.status === 401 &&
			          typeof url === 'string' &&
			          url.includes('/api/') &&
			          !url.includes('mapbox') &&
			          !url.includes('tiles') &&
			          !url.includes('/api/auth/login') &&
			          !url.includes('/api/auth/register') &&
			          (url.startsWith('/') || url.includes(window.location.origin));

			        if (shouldIntercept) {
			          console.log('üîÑ Token expired, attempting refresh...');

			          const refreshed = await this.handleTokenRefresh();
			          if (refreshed) {
			            // Retry la requ√™te originale
			            console.log('‚úÖ Token refreshed, retrying request...');
			            return originalFetch(url, options);
			          } else {
			            // Redirect vers login
			            console.log('‚ùå Refresh failed, redirecting to login...');
			            this.redirectToLogin();
			            return response;
			          }
			        }

			        return response;
			      } catch (error) {
			        // Don't log AbortErrors from external services like Mapbox
			        if (error.name !== 'AbortError') {
			          console.error('Fetch interceptor error:', error);
			        }
			        throw error;
			      }
			    };
			  }

			  async handleTokenRefresh() {
			    // √âviter les appels multiples simultan√©s
			    if (this.isRefreshing) {
			      return new Promise((resolve) => {
			        this.failedRequests.push(resolve);
			      });
			    }

			    this.isRefreshing = true;

			    try {
			      const response = await fetch('/api/auth/refresh', {
			        method: 'POST',
			        headers: {
			          'Content-Type': 'application/json',
			        },
			        credentials: 'include' // Important pour les cookies
			      });

			      const result = await response.json();

			      if (response.ok && result.success) {
			        console.log('‚úÖ Token refresh successful');

			        // R√©soudre toutes les requ√™tes en attente
			        this.failedRequests.forEach(resolve => resolve(true));
			        this.failedRequests = [];

			        return true;
			      } else {
			        console.log('‚ùå Token refresh failed:', result.error);

			        // R√©soudre toutes les requ√™tes en attente avec √©chec
			        this.failedRequests.forEach(resolve => resolve(false));
			        this.failedRequests = [];

			        return false;
			      }
			    } catch (error) {
			      console.error('Token refresh error:', error);

			      // R√©soudre toutes les requ√™tes en attente avec √©chec
			      this.failedRequests.forEach(resolve => resolve(false));
			      this.failedRequests = [];

			      return false;
			    } finally {
			      this.isRefreshing = false;
			    }
			  }

			  redirectToLogin() {
			    // Clear cookies server-side via logout endpoint
			    fetch('/api/auth/logout', {
			      method: 'GET',
			      credentials: 'include'
			    }).catch((error) => {
			      console.log('‚ùå Failed to clear cookies via logout endpoint:', error);
			    });

			    // √âmettre un √©v√©nement pour que l'UI puisse r√©agir
			    window.dispatchEvent(new CustomEvent('authExpired', {
			      detail: { message: 'Your session has expired. Please log in again.' }
			    }));

			    // Optionnel : redirection automatique
			    // window.location.href = '/login';
			  }
			}

			// Initialiser l'intercepteur d√®s que possible
			let authInterceptor;

			function initAuthInterceptor() {
			  if (!authInterceptor) {
			    authInterceptor = new AuthInterceptor();
			    console.log('üîê Auth interceptor initialized');
			  }
			}

			// Initialiser sur DOMContentLoaded
			document.addEventListener('DOMContentLoaded', initAuthInterceptor);

			// Initialiser imm√©diatement si le DOM est d√©j√† charg√©
			if (document.readyState !== 'loading') {
			  initAuthInterceptor();
			}

			// Export pour utilisation dans d'autres scripts
			window.AuthInterceptor = AuthInterceptor;
		</script>
	</body>
</html>

---
import '../styles/globals.css';
import { getLocale } from '../paraglide/runtime.js';
import * as m from '../paraglide/messages.js';
import { ViewTransitions } from 'astro:transitions';
import Loading from '../components/Loading.astro';

interface Props {
	title?: string;
	description?: string;
}

const { title = m.dashboard(), description = "Manage your content easily" } = Astro.props;

// Centralized authentication state
const user = Astro.locals.user;
const isAuthenticated = !!user;
---

<!doctype html>
<html lang={getLocale()}>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="generator" content={Astro.generator} />
		<meta name="description" content={description} />
		<title>{title}</title>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
		<ViewTransitions />
	</head>
	<body class="min-h-screen bg-gray-50 font-sans antialiased">
		<slot user={user} isAuthenticated={isAuthenticated} />

		<!-- Auth Interceptor - G√®re automatiquement le refresh des tokens -->
		<script>
			// Auth Interceptor - G√®re automatiquement le refresh des tokens
			class AuthInterceptor {
			  constructor() {
			    this.isRefreshing = false;
			    this.failedRequests = [];
			    this.setupInterceptor();
			  }

			  setupInterceptor() {
			    // Intercepter les fetch requests pour g√©rer les 401 automatiquement
			    const originalFetch = window.fetch;

			    window.fetch = async (url, options = {}) => {
			      try {
			        const response = await originalFetch(url, options);

			        // Only intercept our own API calls, not external services or auth endpoints
			        const shouldIntercept = response.status === 401 &&
			          typeof url === 'string' &&
			          url.includes('/api/') &&
			          !url.includes('mapbox') &&
			          !url.includes('tiles') &&
			          !url.includes('/api/auth/login') &&
			          !url.includes('/api/auth/register') &&
			          (url.startsWith('/') || url.includes(window.location.origin));

			        if (shouldIntercept) {
			          console.log('üîÑ Token expired, attempting refresh...');

			          const refreshed = await this.handleTokenRefresh();
			          if (refreshed) {
			            // Retry la requ√™te originale
			            console.log('‚úÖ Token refreshed, retrying request...');
			            return originalFetch(url, options);
			          } else {
			            // Redirect vers login
			            console.log('‚ùå Refresh failed, redirecting to login...');
			            this.redirectToLogin();
			            return response;
			          }
			        }

			        return response;
			      } catch (error) {
			        // Don't log AbortErrors from external services like Mapbox
			        if (error.name !== 'AbortError') {
			          console.error('Fetch interceptor error:', error);
			        }
			        throw error;
			      }
			    };
			  }

			  async handleTokenRefresh() {
			    // √âviter les appels multiples simultan√©s
			    if (this.isRefreshing) {
			      return new Promise((resolve) => {
			        this.failedRequests.push(resolve);
			      });
			    }

			    this.isRefreshing = true;

			    try {
			      const response = await fetch('/api/auth/refresh', {
			        method: 'POST',
			        headers: {
			          'Content-Type': 'application/json',
			        },
			        credentials: 'include' // Important pour les cookies
			      });

			      const result = await response.json();

			      if (response.ok && result.success) {
			        console.log('‚úÖ Token refresh successful');

			        // R√©soudre toutes les requ√™tes en attente
			        this.failedRequests.forEach(resolve => resolve(true));
			        this.failedRequests = [];

			        return true;
			      } else {
			        console.log('‚ùå Token refresh failed:', result.error);

			        // R√©soudre toutes les requ√™tes en attente avec √©chec
			        this.failedRequests.forEach(resolve => resolve(false));
			        this.failedRequests = [];

			        return false;
			      }
			    } catch (error) {
			      console.error('Token refresh error:', error);

			      // R√©soudre toutes les requ√™tes en attente avec √©chec
			      this.failedRequests.forEach(resolve => resolve(false));
			      this.failedRequests = [];

			      return false;
			    } finally {
			      this.isRefreshing = false;
			    }
			  }

			  redirectToLogin() {
			    // √âmettre un √©v√©nement pour que l'UI puisse r√©agir
			    window.dispatchEvent(new CustomEvent('authExpired', {
			      detail: { message: 'Your session has expired. Please log in again.' }
			    }));

			    // Optionnel : redirection automatique
			    // window.location.href = '/login';
			  }
			}

			// Initialiser l'intercepteur d√®s que possible
			let authInterceptor;

			function initAuthInterceptor() {
			  if (!authInterceptor) {
			    authInterceptor = new AuthInterceptor();
			    console.log('üîê Auth interceptor initialized');
			  }
			}

			// Initialiser sur DOMContentLoaded
			document.addEventListener('DOMContentLoaded', initAuthInterceptor);

			// Initialiser imm√©diatement si le DOM est d√©j√† charg√©
			if (document.readyState !== 'loading') {
			  initAuthInterceptor();
			}

			// Export pour utilisation dans d'autres scripts
			window.AuthInterceptor = AuthInterceptor;
		</script>
	</body>
</html>

---
import * as m from '../paraglide/messages.js';
import { MAPBOX_ACCESS_TOKEN } from "astro:env/client";

import ShuffleBtn from '../assets/images/shuffle_btn.svg';
import CityBtn from '../assets/images/city.svg';
import CountryBtn from '../assets/images/country.svg';
import PolBtn from '../assets/images/pol.svg';
import RoleBtn from '../assets/images/role.svg';
import StyleBtn from '../assets/images/style.svg';

import Geopoint from '../assets/images/geopoint.svg';
import Cluster1 from '../assets/images/cluster_1.svg';
import Cluster2 from '../assets/images/cluster_2.svg';
import Cluster3 from '../assets/images/cluster_3.svg';

// Get Mapbox token from environment variables
const mapboxToken = MAPBOX_ACCESS_TOKEN;

const filters = [
  { id: "country", label: "Country", icon: CountryBtn, options: ["France", "USA", "Germany", "Japan"] },
  { id: "city", label: "City", icon: CityBtn, options: ["Paris", "Berlin", "Tokyo", "NYC"] },
  { id: "style", label: "Style", icon: StyleBtn, options: ["Jazz", "HipHop", "Techno"] },
  { id: "role", label: "Role", icon: RoleBtn, options: ["DJ", "Producer", "Singer"] },
  { id: "pol", label: "Pol", icon: PolBtn, options: ["Option A", "Option B", "Option C"] },
];

let allArtists = []; // Store all artists for filtering
---

<div class="map-container">
  <div class="map-wrapper">
    <div id="wavmap" class="map"></div>
    <button class="shuffle">
      <img src={ShuffleBtn.src} alt="shuffle" />
    </button>
  </div>
    <div class="filters-container">
      <h2>{m.artist_map_title()}</h2>

      {filters.map(filter => (
        <div key={filter.id} class="filter-wrapper">
          <button
            class="filter"
            data-target={filter.id}
          >
            <img src={filter.icon.src} alt={filter.label} />
          </button>

          <!-- Ligne d'options cachÃ©e par dÃ©faut -->
          <div id={filter.id} class="filter-options hidden mt-2 flex flex-wrap gap-2">
            {filter.options.map(opt => (
              <span>{opt}</span>
            ))}
          </div>
        </div>
      ))}
    </div>
</div>

<script define:vars={{ mapboxToken }}>
  // Fetch real artist data from Directus API
  async function loadApprovedArtists() {
    try {
      console.log('ðŸ” Fetching artists from API...');
      console.log('ðŸ” Current timestamp:', new Date().toISOString());
      const response = await fetch('/api/artists/approved?_t=' + Date.now());
      const data = await response.json();

      console.log('ðŸ” API Response:', data);
      console.log('ðŸ” API Response details:');
      console.log('  - Success:', data.success);
      console.log('  - Count:', data.count);
      console.log('  - Artists array:', data.artists);

      if (data.artists && data.artists.length > 0) {
        data.artists.forEach((artist, index) => {
          console.log(`ðŸŽµ Artist ${index + 1}:`, {
            id: artist.id,
            name: artist.artistName,
            city: artist.city,
            country: artist.country,
            lat: artist.latitude,
            lng: artist.longitude,
            activities: artist.activities,
            genres: artist.genres?.slice(0, 3)
          });
        });
      }

      if (data.success && data.artists && data.artists.length > 0) {
        console.log('âœ… Using real artist data:', data.artists.length, 'artists');
        console.log('ðŸš¨ DATA SOURCE: REAL API DATA');
        return data.artists;
      } else {
        console.log('âš ï¸ No artists found in database');
        return [];
      }
    } catch (error) {
      console.error('ðŸ—ºï¸ Error loading artists:', error);
      return [];
    }
  }

  // Simple filter toggle functionality
  document.querySelectorAll('.filter').forEach(btn => {
    btn.addEventListener('click', () => {
      const targetId = btn.dataset.target;
      const el = document.getElementById(targetId);
      if (el) {
        el.classList.toggle('hidden');
      }
    });
  });

  
  // Cleanup function to properly remove existing map
  function cleanupMap() {
    if (window.wavmapInstance) {
      try {
        window.wavmapInstance.remove();
      } catch (e) {
      }
      window.wavmapInstance = null;
    }
  }
  
  async function initializeMap() {
    const mapContainer = document.getElementById('wavmap');
    
    if (!mapContainer) {
      return;
    }
    
    // Always cleanup existing map first
    cleanupMap();
    
    // Wait for Mapbox GL to load with retry mechanism
    let attempts = 0;
    const maxAttempts = 10;
    
    while (typeof mapboxgl === 'undefined' && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    // Check if Mapbox GL is available
    if (typeof mapboxgl === 'undefined') {
      console.error('ðŸ—ºï¸ Mapbox GL JS not loaded after', maxAttempts, 'attempts');
      return;
    }
    
    // Use token from environment variables
    mapboxgl.accessToken = mapboxToken;
    
    try {

      const europeBounds = [
          [ -30, 15 ], // Coin sud-ouest (plus vers Atlantique/Afrique)
          [ 60, 80 ]   // Coin nord-est (plus vers SibÃ©rie/Arctique)
      ];
      
      const map = new mapboxgl.Map({
        container: 'wavmap',
        style: 'mapbox://styles/mapbox/satellite-v9',
        center: [17.4306, 50.1681], // Centered on Europe (user selected)
        zoom: 2, // Show extended Europe level view
        maxBounds: europeBounds, // Removed for unlimited zoom/pan
        minZoom: 0,
        maxZoom: 18
      });
      
      // Store global instance
      window.wavmapInstance = map;
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl());
      
      // Add fullscreen control  
      map.addControl(new mapboxgl.FullscreenControl());
      
      // Load and add real artist data when map is ready
      map.on('load', async function() {
        // Log current map state
        console.log('ðŸ—ºï¸ Map loaded!');
        console.log('ðŸ“ Initial center:', map.getCenter());
        console.log('ðŸ” Initial zoom:', map.getZoom());

        // Force center on Europe (user selected position)
        map.setCenter([17.4306, 50.1681]);
        map.setZoom(2);

        console.log('ðŸ“ After setCenter - Center:', map.getCenter());
        console.log('ðŸ” After setZoom - Zoom:', map.getZoom());

        // Fetch approved artists from API
        const artists = await loadApprovedArtists();

        if (artists.length === 0) {
          console.log('â„¹ï¸ No artists to display on map');
          return;
        }

        console.log(`ðŸŽµ Loaded ${artists.length} artists for clustering`);
        artists.forEach((artist, i) => {
          if (i < 3) { // Log first 3 for debugging
            console.log(`Artist ${i + 1}:`, {
              name: artist.artistName,
              coords: [artist.longitude, artist.latitude],
              city: artist.city
            });
          }
        });

        // Store artists globally
        allArtists = artists;

        // Convert artist data to GeoJSON format with null checks
        const geojsonData = {
          type: 'FeatureCollection',
          features: artists
            .filter(artist => artist.longitude != null && artist.latitude != null)
            .map(artist => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [
                  parseFloat(artist.longitude) || 0,
                  parseFloat(artist.latitude) || 0
                ]
              },
              properties: {
                id: artist.id || '',
                artistName: artist.artistName || 'Unknown Artist',
                city: artist.city || 'Unknown City',
                country: artist.country || 'Unknown Country',
                activities: Array.isArray(artist.activities) ? artist.activities.join(', ') : '',
                genres: Array.isArray(artist.genres) ? artist.genres.join(', ') : ''
              }
            }))
        };

        // Add cluster source
        console.log('ðŸ—ºï¸ Adding points source with', geojsonData.features.length, 'features');
        map.addSource('points', {
          type: 'geojson',
          data: geojsonData,
          cluster: true,
          clusterMaxZoom: 14,
          clusterRadius: 50
        });

        // ImplÃ©mentation du clustering selon le tutoriel officiel Mapbox
        console.log('âœ… Points source added, adding cluster layers');

        // Ajouter des layers invisibles pour le clustering, remplacÃ©s par des marqueurs HTML
        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'points',
          filter: ['has', 'point_count'],
          paint: {
            'circle-opacity': 0,  // Invisible
            'circle-radius': 0    // Invisible
          }
        });

        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'points',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-opacity': 0,  // Invisible
            'circle-radius': 0    // Invisible
          }
        });

        // SystÃ¨me hybride : clustering Mapbox + marqueurs HTML personnalisÃ©s
        const allMarkers = [];

        function getClusterStyle(pointCount) {
          if (pointCount >= 2 && pointCount <= 5) {
            // Petit cluster avec gradient radial
            return {
              size: '30px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 100%)'
            };
          } else if (pointCount >= 6 && pointCount <= 20) {
            // Cluster moyen
            return {
              size: '40px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 50%, #3E44E6 100%)'
            };
          } else {
            // Gros cluster
            return {
              size: '50px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 30%, #3E44E6 80%, #8FD116 100%)'
            };
          }
        }

        function addCustomMarkers() {
          // Supprimer tous les marqueurs existants
          allMarkers.forEach(marker => marker.remove());
          allMarkers.length = 0;

          // Obtenir les features de clustering via queryRenderedFeatures
          const features = map.queryRenderedFeatures({ layers: ['clusters', 'unclustered-point'] });

          // Si pas de features de clustering, utiliser directement les donnÃ©es artists
          if (features.length === 0) {
            artists.forEach(artist => {
              if (artist.longitude != null && artist.latitude != null) {
                const coordinates = [parseFloat(artist.longitude), parseFloat(artist.latitude)];

                // CrÃ©er un rond rouge simple
                const markerElement = document.createElement('div');
                markerElement.className = 'red-marker';
                markerElement.style.width = '16px';
                markerElement.style.height = '16px';
                markerElement.style.backgroundColor = '#E92C0F';
                markerElement.style.borderRadius = '50%';
                markerElement.style.cursor = 'pointer';
                markerElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

                // CrÃ©er le marqueur
                const marker = new mapboxgl.Marker(markerElement)
                  .setLngLat(coordinates)
                  .addTo(map);

                // Ajouter l'Ã©vÃ©nement click pour popup
                markerElement.addEventListener('click', () => {
                  new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(`
                      <div class="artist-popup">
                        <h3>${artist.artistName || 'Unknown Artist'}</h3>
                        <p><strong>${artist.city || 'Unknown City'}, ${artist.country || 'Unknown Country'}</strong></p>
                        <p><strong>Activities:</strong> ${Array.isArray(artist.activities) ? artist.activities.join(', ') : ''}</p>
                        <p><strong>Genres:</strong> ${Array.isArray(artist.genres) ? artist.genres.join(', ') : ''}</p>
                        <div class="popup-actions">
                          <a href="/artist/${artist.id}" class="view-profile-btn">ðŸ‘¤ Voir le profil</a>
                        </div>
                      </div>
                    `)
                    .addTo(map);
                });

                allMarkers.push(marker);
              }
            });
          } else {
            // Utiliser les features de clustering
            features.forEach(feature => {
              const coordinates = feature.geometry.coordinates;
              const properties = feature.properties;

              if (properties.cluster) {
                // C'est un cluster - utiliser getClusterStyle
                const pointCount = properties.point_count;
                const clusterStyle = getClusterStyle(pointCount);

                const clusterElement = document.createElement('div');
                clusterElement.className = 'custom-cluster';
                clusterElement.style.width = clusterStyle.size;
                clusterElement.style.height = clusterStyle.size;
                clusterElement.style.background = clusterStyle.background;
                clusterElement.style.borderRadius = '50%';
                clusterElement.style.cursor = 'pointer';
                clusterElement.style.position = 'relative';
                clusterElement.style.display = 'flex';
                clusterElement.style.alignItems = 'center';
                clusterElement.style.justifyContent = 'center';
                clusterElement.style.boxShadow = '0 3px 6px rgba(0,0,0,0.3)';

                // Ajouter le nombre de points
                const countLabel = document.createElement('div');
                countLabel.textContent = pointCount;
                countLabel.style.color = '#FFFFFF';
                countLabel.style.fontWeight = 'bold';
                countLabel.style.fontSize = '14px';
                countLabel.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
                clusterElement.appendChild(countLabel);

                // CrÃ©er le marqueur
                const marker = new mapboxgl.Marker(clusterElement)
                  .setLngLat(coordinates)
                  .addTo(map);

                // Ajouter l'Ã©vÃ©nement click pour zoomer
                clusterElement.addEventListener('click', () => {
                  const clusterId = properties.cluster_id;
                  map.getSource('points').getClusterExpansionZoom(clusterId, (err, zoom) => {
                    if (err) return;
                    map.easeTo({
                      center: coordinates,
                      zoom: zoom
                    });
                  });
                });

                allMarkers.push(marker);

              } else {
                // C'est un point individuel
                const markerElement = document.createElement('div');
                markerElement.className = 'red-marker';
                markerElement.style.width = '16px';
                markerElement.style.height = '16px';
                markerElement.style.backgroundColor = '#E92C0F';
                markerElement.style.borderRadius = '50%';
                markerElement.style.cursor = 'pointer';
                markerElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

                // CrÃ©er le marqueur
                const marker = new mapboxgl.Marker(markerElement)
                  .setLngLat(coordinates)
                  .addTo(map);

                // Ajouter l'Ã©vÃ©nement click pour popup
                markerElement.addEventListener('click', () => {
                  new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(`
                      <div class="artist-popup">
                        <h3>${properties.artistName}</h3>
                        <p><strong>${properties.city}, ${properties.country}</strong></p>
                        <p><strong>Activities:</strong> ${properties.activities}</p>
                        <p><strong>Genres:</strong> ${properties.genres}</p>
                        <div class="popup-actions">
                          <a href="/artist/${properties.id}" class="view-profile-btn">ðŸ‘¤ Voir le profil</a>
                        </div>
                      </div>
                    `)
                    .addTo(map);
                });

                allMarkers.push(marker);
              }
            });
          }

          console.log(`ðŸŽ¯ AjoutÃ© ${allMarkers.length} marqueurs (${features.length} features dÃ©tectÃ©es)`);
        }

        // Ajouter les marqueurs initialement
        addCustomMarkers();

        // Mettre Ã  jour les marqueurs lors des changements
        map.on('data', (e) => {
          if (e.sourceId === 'points' && e.isSourceLoaded) {
            addCustomMarkers();
          }
        });

        map.on('zoomend', addCustomMarkers);
        map.on('moveend', addCustomMarkers);

        // Add click handler to get coordinates easily
        map.on('click', function(e) {
          const coords = e.lngLat;
          console.log('ðŸŽ¯ Clicked coordinates:');
          console.log(`   Longitude: ${coords.lng.toFixed(4)}`);
          console.log(`   Latitude: ${coords.lat.toFixed(4)}`);
          console.log(`   Array format: [${coords.lng.toFixed(4)}, ${coords.lat.toFixed(4)}]`);
        });
      });

      map.on('error', function(e) {
        console.error('ðŸ—ºï¸ Mapbox error:', e);
      });
      
    } catch (error) {
      console.error('ðŸ—ºï¸ Error initializing Mapbox:', error);
    }
  }
  
  // Cleanup before page swap (View Transitions)
  document.addEventListener('astro:before-swap', () => {
    cleanupMap();
  });
  
  // Reinitialize after page swap (View Transitions)  
  document.addEventListener('astro:after-swap', () => {
    // Small delay to ensure DOM is ready
    setTimeout(initializeMap, 50);
  });
  
  // Initialize map on page load (View Transitions)
  document.addEventListener('astro:page-load', () => {
    setTimeout(initializeMap, 50);
  });
  
  // Initialize on DOM content loaded (first load)
  document.addEventListener('DOMContentLoaded', () => {
    initializeMap();
  });
  
  // Fallback for immediate execution
  if (document.readyState !== 'loading') {
    initializeMap();
  }
  
</script>

<style>
  .map-container {
    width: 100%;
    margin: 0 auto;
    display: flex;
    color: black;
    gap: 2rem;
    padding: 1rem
  }

  .filters-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    text-align: left;
    align-items: flex-start;
  }

  .map-container h2 {
    font-size: 2rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 1rem 0;
    text-align: center;
    background-clip: text;
    -webkit-background-clip: text;
  }

  .shuffle {
    position: absolute;
    left: 1rem;
    bottom: 1rem;
    width: 150px;
    z-index: 3;
  }

  .filter img {
    height: 50px;
  }

  .filter-wrapper {
    position: relative;
  }

  .filter-options.hidden {
    display: none;
  }

  .map-wrapper {
    max-width: 70%;
    flex: 1;
    position: relative;
  }

  .map {
    width: 100%;
    height: 600px;
    overflow: hidden;
  }

  /* Appliquer le filtre uniquement sur les tuiles de la carte, pas sur les marqueurs */
  .map :global(.mapboxgl-canvas-container canvas) {
    filter:
      grayscale(100%)
      contrast(100%)
      saturate(220%)
      brightness(220%)
      hue-rotate(180deg);
  }

  .map .mapboxgl-ctrl {
    filter: none;
  }

  /* Style pour les marqueurs rouges - plus besoin de protection de filtre */
  .map :global(.red-marker) {
    transition: transform 0.2s ease;
  }

  .map :global(.red-marker:hover) {
    transform: scale(1.3);
  }

  /* Style pour les clusters avec gradient */
  .map :global(.custom-cluster) {
    transition: transform 0.2s ease;
  }

  .map :global(.custom-cluster:hover) {
    transform: scale(1.1);
  }

  /* Custom popup styles */
  :global(.mapboxgl-popup-content) {
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  }

  :global(.artist-popup h3) {
    margin: 0 0 0.5rem 0;
    color: #1f2937;
    font-size: 1.1rem;
    font-weight: 600;
  }

  :global(.artist-popup p) {
    margin: 0.25rem 0;
    font-size: 0.9rem;
    color: #6b7280;
  }

  :global(.artist-popup strong) {
    color: #374151;
  }

  :global(.artist-popup .social-links) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
  }

  :global(.artist-popup .social-links a) {
    display: inline-block;
    margin: 0 0.5rem 0.25rem 0;
    color: #6366f1;
    text-decoration: none;
    font-size: 0.8rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    background-color: #f8f9ff;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .social-links a:hover) {
    background-color: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  :global(.artist-popup .popup-actions) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  :global(.artist-popup .view-profile-btn) {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .view-profile-btn:hover) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  /* Responsive */
  @media (max-width: 768px) {
    .map-container {
      padding: 2rem 1.5rem;
      margin: 0 1rem;
    }

    .map {
      height: 400px;
    }
  }
</style>

<!-- Import Mapbox CSS and JS -->
<link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
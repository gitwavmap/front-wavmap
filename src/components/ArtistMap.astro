---
import * as m from '../paraglide/messages.js';
import { MAPBOX_ACCESS_TOKEN } from "astro:env/client";

import ShuffleBtn from '../assets/images/shuffle_btn.svg';
import CityBtn from '../assets/images/city.svg';
import CountryBtn from '../assets/images/country.svg';
import PolBtn from '../assets/images/pol.svg';
import RoleBtn from '../assets/images/role.svg';
import StyleBtn from '../assets/images/style.svg';
import BackBtn from '../assets/images/close_btn.svg';
import BackBtnBg from '../assets/images/close_bg.svg';
import HoverLink from '../components/HoverLink.astro';
import Separator from '../assets/images/separator.svg';

// Import SVG button backgrounds
import Btn1 from '../assets/images/btn_1.svg';
import Btn2 from '../assets/images/btn_2.svg';
import Btn3 from '../assets/images/btn_3.svg';
import Btn4 from '../assets/images/btn_4.svg';
import Btn5 from '../assets/images/btn_5.svg';
import Btn6 from '../assets/images/btn_6.svg';
import Btn7 from '../assets/images/btn_7.svg';
import Btn8 from '../assets/images/btn_8.svg';
import Btn9 from '../assets/images/btn_9.svg';
import Btn10 from '../assets/images/btn_10.svg';
import Btn11 from '../assets/images/btn_11.svg';
import Btn12 from '../assets/images/btn_12.svg';
import Btn13 from '../assets/images/btn_13.svg';
import Btn14 from '../assets/images/btn_14.svg';

// Get Mapbox token from environment variables
const mapboxToken = MAPBOX_ACCESS_TOKEN;

const filters = [
  { id: "country", label: "Country", icon: CountryBtn, options: [] }, // Populated dynamically
  { id: "city", label: "City", icon: CityBtn, options: [] }, // Populated dynamically
  { id: "style", label: "Style", icon: StyleBtn, options: ["Jazz", "HipHop", "Techno"] },
  { id: "role", label: "Role", icon: RoleBtn, options: ["DJ", "Producer", "Singer"] },
  { id: "pol", label: "Pol", icon: PolBtn, options: ["Option A", "Option B", "Option C"] },
];

let allArtists = []; // Store all artists for filtering
let selectedFilters = { cities: [], countries: [], styles: [], roles: [], pol: [] }; // Track selected filters
---

<div class="map-container">
  <div class="map-wrapper">
    <div id="wavmap" class="map"></div>
    <button class="shuffle">
      <img src={ShuffleBtn.src} alt="shuffle" />
    </button>
  </div>
    <div class="filters-container">
      <!-- Filters Content (shown by default) -->
      <div id="filters-content" class="filters-content">
        {filters.map(filter => (
          <div key={filter.id} class="filter-wrapper">
            <button
              class="filter"
              data-target={`filter-${filter.id}`}
            >
              <img src={filter.icon.src} alt={filter.label} />
            </button>

            <!-- Ligne d'options cachée par défaut -->
            <div id={`filter-${filter.id}`} class="filter-options hidden mt-2 flex flex-wrap gap-2">
              <div id={`${filter.id}-dynamic-options`} class="dynamic-filter-options flex flex-wrap gap-2">
                <!-- Options will be populated dynamically by JavaScript -->
              </div>
            </div>
          </div>
        ))}

        <!-- Global Clear All Filters Button -->
        <button id="clear-all-filters-global" class="clear-all-filters-btn hidden">
          Clear All Filters
        </button>
      </div>

      <!-- Artist Detail Content (hidden by default) -->
      <div id="artist-content" class="artist-content hidden">
        <div style={{backgroundColor: "white", padding: "1rem", height: "calc(100% - 2rem)", margin: "1rem", boxSizing: "border-box", overflowY: "auto"}}>

          <div id="close-artist-panel" class="close-hover-btn">
            <img src={BackBtn.src} alt="Close" class="close-btn-normal" />
            <img src={BackBtnBg.src} alt="Close" class="close-btn-hover" />
          </div>


          <!-- Artist Name -->
          <h2 id="artist-name-display" class="artist-name">Artist Name</h2>

          <!-- Pronouns -->
          <div id="artist-pronouns-container" class="artist-pronouns-container hidden">
            <p id="artist-pronouns" class="artist-pronouns"></p>
          </div>

          <!-- Location -->
          <h3 id="artist-location" class="artist-location">CITY - COUNTRY</h3>

          <!-- Bio -->
          <div class="artist-bio">
            <p id="artist-bio">Artist bio will appear here...</p>
          </div>

          <!-- Decorative line -->
          <div class="separator-line">
            <img src={Separator.src} alt="Separator" />
          </div>

          <!-- Social Media Links -->
          <div class="social-media-links">
            <span id="instagram-link" class="social-link">IN</span>
            <span class="separator">|</span>
            <span id="soundcloud-link" class="social-link">SC</span>
            <span class="separator">|</span>
            <span id="spotify-link" class="social-link">SP</span>
          </div>

          <!-- Activities & Genres Tags -->
          <div class="tags-line">
            <div id="all-tags" class="tags-inline">
              <!-- Tags will be populated dynamically -->
            </div>
          </div>

          <!-- Decorative line -->
          <div class="separator-line separator-bottom">
            <img src={Separator.src} alt="Separator" />
          </div>

          <!-- Social/Political Topics -->
          <div id="social-topics-container" class="social-topics-container hidden">
            <h4 class="section-title">Social & Political Engagement</h4>
            <div id="social-topics" class="topics-content">
              <!-- Social topics will be populated dynamically -->
            </div>
          </div>

          <!-- Themes & Development -->
          <div id="themes-container" class="themes-container hidden">
            <h4 class="section-title">Themes & Development</h4>
            <p id="themes-development-display" class="themes-content"></p>
          </div>

          <!-- Club Politics / Political Approach -->
          <div id="club-politics-container" class="club-politics-container hidden">
            <h4 class="section-title">Political Approach</h4>
            <p id="club-politics-display" class="club-politics-content"></p>
          </div>

        </div>
      </div>
    </div>
</div>

<script define:vars={{ mapboxToken, Btn1, Btn2, Btn3, Btn4, Btn5, Btn6, Btn7, Btn8, Btn9, Btn10, Btn11, Btn12, Btn13, Btn14 }}>
  // Import cities data to get country name mapping
  let countryMapping = {};

  // SVG background assets
  const buttonBackgrounds = {
    1: Btn1.src,
    2: Btn2.src,
    3: Btn3.src,
    4: Btn4.src,
    5: Btn5.src,
    6: Btn6.src,
    7: Btn7.src,
    8: Btn8.src,
    9: Btn9.src,
    10: Btn10.src,
    11: Btn11.src,
    12: Btn12.src,
    13: Btn13.src,
    14: Btn14.src
  };

  // Function to determine button background size based on text length
  function getButtonSize(text) {
    const length = text.length;
    if (length <= 3) return 4;        // Very short: btn_4.svg
    if (length <= 5) return 5;        // Short: btn_5.svg
    if (length <= 8) return 6;        // Medium-short: btn_6.svg
    if (length <= 12) return 7;       // Medium: btn_7.svg
    if (length <= 16) return 8;       // Medium-long: btn_8.svg
    if (length <= 20) return 9;       // Long: btn_9.svg
    if (length <= 24) return 10;      // Very long: btn_10.svg
    if (length <= 28) return 11;      // Extra long: btn_11.svg
    if (length <= 32) return 12;      // btn_12.svg
    if (length <= 36) return 13;      // btn_13.svg
    return 14;                        // Maximum: btn_14.svg (> 36 characters)
  }

  // Initialize country mapping directly (based on european-cities.json data)
  function initCountryMapping() {
    countryMapping = {
      'AT': 'Austria',
      'BE': 'Belgium',
      'CH': 'Switzerland',
      'CZ': 'Czech Republic',
      'DE': 'Germany',
      'DK': 'Denmark',
      'ES': 'Spain',
      'FI': 'Finland',
      'FR': 'France',
      'GB': 'United Kingdom',
      'GR': 'Greece',
      'HU': 'Hungary',
      'IE': 'Ireland',
      'IT': 'Italy',
      'NL': 'Netherlands',
      'NO': 'Norway',
      'PL': 'Poland',
      'PT': 'Portugal',
      'RO': 'Romania',
      'SE': 'Sweden'
    };

    console.log('🗺️ Initialized country mapping:', countryMapping);
    return countryMapping;
  }

  // Function to get country display name from country code
  function getCountryDisplayName(countryCode) {
    return countryMapping[countryCode] || countryCode;
  }

  // Mapping for social topics values to display labels
  function getSocialTopicLabel(value) {
    const socialTopicsLabels = {
      'queerrights': 'Queer Rights',
      'flintarepresentation': 'FLINTA Representation',
      'genderequality': 'Gender Equality',
      'anti-racism': 'Anti-Racism',
      'decolonialism': 'Decolonialism',
      'acccessibilityforpeoplewithdisabilities': 'Accessibility For People With Disabilities',
      'economicequalityclasssolidarity': 'Economic Equality & Class Solidarity',
      'climatejustice': 'Climate Justice',
      'geographicmarginalization': 'Geographic Marginalization'
    };

    // Return mapped label if exists, otherwise format the value automatically
    if (socialTopicsLabels[value]) {
      return socialTopicsLabels[value];
    }

    // Fallback formatting for club politics or other free text
    return value
      .replace(/([a-z])([A-Z])/g, '$1 $2') // camelCase to spaces
      .replace(/[_-]/g, ' ') // underscores/dashes to spaces
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Filter management variables - factorized structure
  let selectedFilters = {
    cities: [],
    countries: [],
    activities: [], // roles
    genres: [], // styles
    socialTopics: [], // political topics (legacy)
    political: [] // combined political topics
  };
  let filteredArtists = [];
  let currentArtistMarkers = []; // Store current markers for filtering


  // Helper function to extract unique values from arrays in artist data
  function extractUniqueValues(artists, field, isArray = false) {
    const values = new Set();

    artists.forEach(artist => {
      if (isArray && Array.isArray(artist[field])) {
        artist[field].forEach(item => {
          if (item && item.trim()) values.add(item.trim());
        });
      } else if (!isArray && artist[field] && artist[field].trim()) {
        values.add(artist[field].trim());
      }
    });

    return [...values].sort();
  }

  // Special function to extract political topics from both socialTopics and clubPolitics
  function extractPoliticalTopics(artists) {
    const values = new Set();
    artists.forEach(artist => {
      // Add social topics (array)
      if (Array.isArray(artist.socialTopics)) {
        artist.socialTopics.forEach(topic => {
          if (topic && topic.trim()) values.add(topic.trim());
        });
      }
      // Add club politics (string)
      if (artist.clubPolitics && artist.clubPolitics.trim()) {
        values.add(artist.clubPolitics.trim());
      }
    });
    return [...values].sort();
  }

  // Function to populate dynamic filter options - factorized
  function populateFilterOptions(artists) {
    console.log('🔧 Starting to populate filter options with', artists.length, 'artists');

    // Define filter mappings - what data to extract and how to display it
    const filterConfigs = {
      'country': {
        data: extractUniqueValues(artists, 'country'),
        displayTransform: getCountryDisplayName, // Transform codes to names
        filterType: 'country',
        cssClass: 'country-filter'
      },
      'city': {
        data: extractUniqueValues(artists, 'city'),
        displayTransform: null, // No transformation needed
        filterType: 'city',
        cssClass: 'city-filter'
      },
      'role': {
        data: extractUniqueValues(artists, 'activities', true), // Array field
        displayTransform: null,
        filterType: 'activities',
        cssClass: 'activities-filter'
      },
      'style': {
        data: extractUniqueValues(artists, 'genres', true), // Array field
        displayTransform: null,
        filterType: 'genres',
        cssClass: 'genres-filter'
      },
      'pol': {
        data: extractPoliticalTopics(artists), // Combined social topics and club politics
        displayTransform: getSocialTopicLabel, // Transform values to readable labels
        filterType: 'political',
        cssClass: 'political-filter'
      }
    };

    // Populate each filter type
    Object.entries(filterConfigs).forEach(([filterId, config]) => {
      const container = document.getElementById(`${filterId}-dynamic-options`);
      console.log(`🔍 Looking for container: ${filterId}-dynamic-options`, container ? '✅ Found' : '❌ Not found');

      if (container && config.data.length > 0) {
        const optionsHTML = config.data.map(value => {
          const displayValue = config.displayTransform ? config.displayTransform(value) : value;
          const buttonSize = getButtonSize(displayValue);
          return `<span class="filter-option ${config.cssClass}" data-filter-type="${config.filterType}" data-value="${value}" data-button-size="${buttonSize}">${displayValue}</span>`;
        }).join('');

        container.innerHTML = optionsHTML;
        console.log(`🏷️ Populated ${filterId} filter with ${config.data.length} options:`, config.data.slice(0, 5));
      } else if (!container) {
        console.warn(`⚠️ Container not found for ${filterId}`);
      } else if (config.data.length === 0) {
        console.warn(`⚠️ No data for ${filterId}`);
      }
    });

    console.log('✅ Filter population complete');
  }

  // Function to handle filter selection - factorized
  function handleFilterClick(element) {
    // Ensure we have valid data and the map is ready
    if (!element || !allArtists || allArtists.length === 0) {
      console.warn('⚠️ Filter click ignored - data not ready:', {
        element: !!element,
        allArtists: allArtists ? allArtists.length : 0
      });
      return;
    }

    const filterType = element.dataset.filterType;
    const value = element.dataset.value;
    const isSelected = element.classList.contains('selected');

    console.log('🎯 Filter clicked:', { filterType, value, isSelected });

    // Map filter types to selectedFilters keys
    const filterTypeMap = {
      'city': 'cities',
      'country': 'countries',
      'activities': 'activities',
      'genres': 'genres',
      'socialTopics': 'socialTopics',
      'political': 'political'
    };

    const filterKey = filterTypeMap[filterType];
    if (!filterKey) {
      console.warn('⚠️ Unknown filter type:', filterType);
      return;
    }

    // Toggle selection
    if (isSelected) {
      // Deselect
      element.classList.remove('selected');
      element.style.backgroundImage = '';
      element.style.opacity = '1';
      selectedFilters[filterKey] = selectedFilters[filterKey].filter(item => item !== value);
      console.log(`❌ Deselected ${filterType}:`, value);
    } else {
      // Select
      element.classList.add('selected');
      // Apply SVG background based on button size
      const buttonSize = element.dataset.buttonSize;
      const backgroundUrl = buttonBackgrounds[buttonSize];
      if (backgroundUrl) {
        element.style.backgroundImage = `url('${backgroundUrl}')`;
        element.style.backgroundSize = 'contain';
        element.style.backgroundRepeat = 'no-repeat';
        element.style.backgroundPosition = 'center';
        element.style.opacity = '1';

        // Apply size-specific dimensions
        const sizes = {
          1: { width: '93px', height: '93px' },
          2: { width: '137px', height: '93px' },
          3: { width: '181px', height: '93px' },
          4: { width: '226px', height: '93px' },
          5: { width: '270px', height: '93px' },
          6: { width: '315px', height: '93px' },
          7: { width: '360px', height: '93px' }
        };

        // Don't change width or height - keep consistent sizing
      }
      selectedFilters[filterKey].push(value);
      console.log(`✅ Selected ${filterType}:`, value);
    }

    console.log('📊 Current selections:', selectedFilters);

    // Update clear filter button visibility
    updateClearFilterButton();

    // Apply filters to map
    applyFilters();
  }

  // Function to update clear filter button visibility - factorized
  function updateClearFilterButton() {
    const clearBtn = document.getElementById('clear-all-filters-global');
    if (clearBtn) {
      const hasActiveFilters = Object.values(selectedFilters).some(arr => arr.length > 0);
      if (hasActiveFilters) {
        clearBtn.classList.remove('hidden');
      } else {
        clearBtn.classList.add('hidden');
      }
    }
  }

  // Function to clear all filters - factorized
  function clearAllFilters() {
    // Reset all filter arrays
    Object.keys(selectedFilters).forEach(key => {
      selectedFilters[key] = [];
    });

    // Remove selected class from all filter elements and clear backgrounds
    document.querySelectorAll('.filter-option.selected').forEach(element => {
      element.classList.remove('selected');
      element.style.backgroundImage = '';
      element.style.opacity = '1';
    });

    console.log('🧹 All filters cleared');

    // Update clear button visibility
    updateClearFilterButton();

    // Reset map to show all artists
    applyFilters();
  }

  // Function to apply filters to the map - factorized with smart AND logic
  function applyFilters() {
    const hasActiveFilters = Object.values(selectedFilters).some(arr => arr.length > 0);

    if (!hasActiveFilters) {
      // No filters active, show all artists
      filteredArtists = allArtists;
    } else {
      // Filter artists using AND logic across all active filter types
      filteredArtists = allArtists.filter(artist => {
        // City filter
        const cityMatch = selectedFilters.cities.length === 0 ||
          selectedFilters.cities.includes(artist.city);

        // Country filter
        const countryMatch = selectedFilters.countries.length === 0 ||
          selectedFilters.countries.includes(artist.country);

        // Activities/Roles filter (check if artist has ANY of the selected activities)
        const activitiesMatch = selectedFilters.activities.length === 0 ||
          (Array.isArray(artist.activities) &&
           artist.activities.some(activity => selectedFilters.activities.includes(activity)));

        // Genres/Styles filter (check if artist has ANY of the selected genres)
        const genresMatch = selectedFilters.genres.length === 0 ||
          (Array.isArray(artist.genres) &&
           artist.genres.some(genre => selectedFilters.genres.includes(genre)));

        // Political filter (check if artist has ANY of the selected political topics)
        const politicalMatch = selectedFilters.political.length === 0 ||
          // Check both socialTopics array and clubPolitics string
          (Array.isArray(artist.socialTopics) &&
           artist.socialTopics.some(topic => selectedFilters.political.includes(topic))) ||
          (artist.clubPolitics && selectedFilters.political.includes(artist.clubPolitics));

        // All active filter conditions must be true (AND logic)
        return cityMatch && countryMatch && activitiesMatch && genresMatch && politicalMatch;
      });
    }

    console.log(`🔍 Filtering result: ${filteredArtists.length} of ${allArtists.length} artists match filters`);

    // Update map markers
    updateMapMarkers();
  }

  // Function to update map markers based on filtered artists
  function updateMapMarkers() {
    if (!window.wavmapInstance) {
      console.log('⚠️ Map instance not available');
      return;
    }

    const map = window.wavmapInstance;

    console.log('🗺️ Updating map with filtered artists:', filteredArtists.length);

    // Update the map source data with filtered artists
    const geojsonData = {
      type: 'FeatureCollection',
      features: filteredArtists
        .filter(artist => artist.longitude != null && artist.latitude != null)
        .map(artist => ({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: [
              parseFloat(artist.longitude) || 0,
              parseFloat(artist.latitude) || 0
            ]
          },
          properties: {
            id: artist.id || '',
            artistName: artist.artistName || 'Unknown Artist',
            city: artist.city || 'Unknown City',
            country: artist.country || 'Unknown Country',
            activities: Array.isArray(artist.activities) ? artist.activities.join(', ') : '',
            genres: Array.isArray(artist.genres) ? artist.genres.join(', ') : ''
          }
        }))
    };

    console.log('📍 GeoJSON features count:', geojsonData.features.length);

    // Update map source
    if (map.getSource('points')) {
      map.getSource('points').setData(geojsonData);
      console.log('✅ Map source updated successfully');

      // Force refresh of custom markers with minimal zoom change
      setTimeout(() => {
        console.log('🔄 Forcing marker refresh with minimal movement...');
        // Use the smallest possible zoom change to trigger queryRenderedFeatures
        const currentZoom = map.getZoom();
        map.setZoom(currentZoom + 0.00001); // Extremely tiny zoom change
        setTimeout(() => {
          map.setZoom(currentZoom); // Reset to original zoom
        }, 10); // Much faster reset
      }, 50);
    } else {
      console.log('❌ Map source "points" not found');
    }

    // Build readable filter summary
    const activeFilters = [];
    Object.entries(selectedFilters).forEach(([key, values]) => {
      if (values.length > 0) {
        const displayKey = key.charAt(0).toUpperCase() + key.slice(1);
        activeFilters.push(`${displayKey}: ${values.slice(0, 3).join(', ')}${values.length > 3 ? '...' : ''}`);
      }
    });

    console.log(`🎯 Applied filters: ${activeFilters.length > 0 ? activeFilters.join(' | ') : 'None'}`);
    console.log(`📍 Showing ${filteredArtists.length} of ${allArtists.length} artists`);
  }

  // Fetch real artist data from Directus API
  async function loadApprovedArtists() {
    try {
      console.log('🔍 Fetching artists from API...');
      console.log('🔍 Current timestamp:', new Date().toISOString());
      const response = await fetch('/api/artists/approved?_t=' + Date.now());
      const data = await response.json();

      console.log('🔍 API Response:', data);
      console.log('🔍 API Response details:');
      console.log('  - Success:', data.success);
      console.log('  - Count:', data.count);
      console.log('  - Artists array:', data.artists);

      if (data.artists && data.artists.length > 0) {
        data.artists.forEach((artist, index) => {
          console.log(`🎵 Artist ${index + 1}:`, {
            id: artist.id,
            name: artist.artistName,
            city: artist.city,
            country: artist.country,
            lat: artist.latitude,
            lng: artist.longitude,
            activities: artist.activities,
            genres: artist.genres?.slice(0, 3)
          });
        });
      }

      if (data.success && data.artists && data.artists.length > 0) {
        console.log('✅ Using real artist data:', data.artists.length, 'artists');
        console.log('🚨 DATA SOURCE: REAL API DATA');
        return data.artists;
      } else {
        console.log('⚠️ No artists found in database');
        return [];
      }
    } catch (error) {
      console.error('🗺️ Error loading artists:', error);
      return [];
    }
  }


  // Function to get random artist from filtered artists
  function getRandomArtist() {
    if (!filteredArtists || filteredArtists.length === 0) {
      console.log('⚠️ No artists available for shuffle');
      return null;
    }

    const randomIndex = Math.floor(Math.random() * filteredArtists.length);
    const randomArtist = filteredArtists[randomIndex];

    console.log('🎲 Shuffled to random artist:', randomArtist.artistName);
    return randomArtist;
  }

  // Function to handle shuffle button click
  function handleShuffle() {
    const randomArtist = getRandomArtist();
    if (!randomArtist) return;

    // Center map on artist coordinates
    if (window.wavmapInstance && randomArtist.longitude != null && randomArtist.latitude != null) {
      const map = window.wavmapInstance;

      // Fly to the artist location with a nice animation
      map.flyTo({
        center: [parseFloat(randomArtist.longitude), parseFloat(randomArtist.latitude)],
        zoom: 12, // Zoom in to see the artist location clearly
        duration: 2000, // 2 second animation
        essential: true
      });

      // Wait for the animation to complete, then show artist detail
      setTimeout(() => {
        showArtistDetail(randomArtist);
      }, 2200); // Slightly after animation ends
    } else {
      // If no map or coordinates, just show artist detail
      showArtistDetail(randomArtist);
    }
  }

  // Functions to toggle between filters and artist content
  function showArtistDetail(artist) {
    const filtersContent = document.getElementById('filters-content');
    const artistContent = document.getElementById('artist-content');

    if (!filtersContent || !artistContent) return;

    // Hide filters, show artist details
    filtersContent.classList.add('hidden');
    artistContent.classList.remove('hidden');

    console.log('🎨 Showing artist detail for:', artist.artistName);
    console.log('🔍 Full artist object:', artist);
    console.log('🔍 Artist keys:', Object.keys(artist));
    console.log('🔍 themesDevelopment:', artist.themesDevelopment);
    console.log('🔍 clubPolitics:', artist.clubPolitics);

    // Populate basic info
    const artistNameElement = document.getElementById('artist-name-display');
    console.log('📝 Setting artist name:', artist.artistName, 'Element:', artistNameElement);
    artistNameElement.textContent = artist.artistName || 'Unknown Artist';

    // Use full country name instead of code
    const countryName = getCountryDisplayName(artist.country) || artist.country || 'Unknown Country';
    document.getElementById('artist-location').textContent =
      `${(artist.city || 'Unknown City').toUpperCase()} - ${countryName.toUpperCase()}`;

    // Pronouns
    const pronounsContainer = document.getElementById('artist-pronouns-container');
    const pronounsElement = document.getElementById('artist-pronouns');

    if (artist.pronouns && artist.pronouns.trim()) {
      pronounsContainer.classList.remove('hidden');
      pronounsElement.textContent = `Pronouns: ${artist.pronouns}`;
    } else {
      pronounsContainer.classList.add('hidden');
    }


    // Set bio
    document.getElementById('artist-bio').textContent = artist.bio || 'No bio available.';

    // Handle social media links
    const instagramLink = document.getElementById('instagram-link');
    const soundcloudLink = document.getElementById('soundcloud-link');
    const spotifyLink = document.getElementById('spotify-link');

    // Instagram link
    if (artist.instagram && artist.instagram.trim()) {
      instagramLink.onclick = () => window.open(artist.instagram, '_blank');
      instagramLink.style.color = '#000';
      instagramLink.style.cursor = 'pointer';
      instagramLink.classList.remove('disabled');
    } else {
      instagramLink.style.color = '#ccc';
      instagramLink.style.cursor = 'default';
      instagramLink.onclick = null;
      instagramLink.classList.add('disabled');
    }

    // SoundCloud link
    if (artist.soundcloud && artist.soundcloud.trim()) {
      soundcloudLink.onclick = () => window.open(artist.soundcloud, '_blank');
      soundcloudLink.style.color = '#000';
      soundcloudLink.style.cursor = 'pointer';
      soundcloudLink.classList.remove('disabled');
    } else {
      soundcloudLink.style.color = '#ccc';
      soundcloudLink.style.cursor = 'default';
      soundcloudLink.onclick = null;
      soundcloudLink.classList.add('disabled');
    }

    // Spotify link
    if (artist.spotify && artist.spotify.trim()) {
      spotifyLink.onclick = () => window.open(artist.spotify, '_blank');
      spotifyLink.style.color = '#000';
      spotifyLink.style.cursor = 'pointer';
      spotifyLink.classList.remove('disabled');
    } else {
      spotifyLink.style.color = '#ccc';
      spotifyLink.style.cursor = 'default';
      spotifyLink.onclick = null;
      spotifyLink.classList.add('disabled');
    }

    // Populate ALL tags on single line
    const allTagsContainer = document.getElementById('all-tags');
    const allTags = [];

    // Add activities first
    if (artist.activities && Array.isArray(artist.activities)) {
      allTags.push(...artist.activities);
    }

    // Add genres after
    if (artist.genres && Array.isArray(artist.genres)) {
      allTags.push(...artist.genres);
    }

    if (allTags.length > 0) {
      const tagsHTML = allTags.map((tag, index) =>
        index < allTags.length - 1
          ? `<span class="tag-inline">${tag}</span><span class="tag-separator">|</span>`
          : `<span class="tag-inline">${tag}</span>`
      ).join('');
      allTagsContainer.innerHTML = tagsHTML;
    }

    // Social/Political Topics
    const socialTopicsContainer = document.getElementById('social-topics-container');
    const socialTopicsElement = document.getElementById('social-topics');

    if (artist.socialTopics && Array.isArray(artist.socialTopics) && artist.socialTopics.length > 0) {
      socialTopicsContainer.classList.remove('hidden');
      const topicsHTML = artist.socialTopics.map(topic =>
        `<span class="topic-tag">${getSocialTopicLabel(topic)}</span>`
      ).join('');
      socialTopicsElement.innerHTML = topicsHTML;
    } else {
      socialTopicsContainer.classList.add('hidden');
    }

    // Themes & Development
    const themesContainer = document.getElementById('themes-container');
    const themesElement = document.getElementById('themes-development-display');

    console.log('🎭 Themes section - Value:', artist.themesDevelopment, 'Container:', themesContainer, 'Element:', themesElement);
    if (artist.themesDevelopment && artist.themesDevelopment.trim()) {
      console.log('✅ Showing themes section');
      themesContainer.classList.remove('hidden');
      themesElement.textContent = artist.themesDevelopment;
      console.log('📝 Set themes text to:', themesElement.textContent);
    } else {
      console.log('❌ Hiding themes section');
      themesContainer.classList.add('hidden');
    }

    // Club Politics
    const clubPoliticsContainer = document.getElementById('club-politics-container');
    const clubPoliticsElement = document.getElementById('club-politics-display');

    console.log('🏛️ Politics section - Value:', artist.clubPolitics, 'Container:', clubPoliticsContainer, 'Element:', clubPoliticsElement);
    if (artist.clubPolitics && artist.clubPolitics.trim()) {
      console.log('✅ Showing politics section');
      clubPoliticsContainer.classList.remove('hidden');
      clubPoliticsElement.textContent = artist.clubPolitics;
      console.log('📝 Set politics text to:', clubPoliticsElement.textContent);
    } else {
      console.log('❌ Hiding politics section');
      clubPoliticsContainer.classList.add('hidden');
    }
  }

  function showFiltersContent() {
    const filtersContent = document.getElementById('filters-content');
    const artistContent = document.getElementById('artist-content');

    if (!filtersContent || !artistContent) return;

    // Show filters, hide artist details
    filtersContent.classList.remove('hidden');
    artistContent.classList.add('hidden');
  }

  // Centralized Event Manager - follows Astro best practices
  class EventManager {
    constructor() {
      this.initialized = false;
      this.hoverTimeout = null;
      this.eventHandlers = new Map();
    }

    init() {
      if (this.initialized) {
        console.log('🎯 EventManager already initialized');
        return;
      }

      console.log('🎯 Initializing EventManager...');
      this.attachDelegatedEvents();
      this.attachDirectEvents();
      this.initialized = true;
      console.log('✅ EventManager initialized successfully');
    }

    cleanup() {
      console.log('🧹 Cleaning up EventManager...');
      // Remove all event handlers
      this.eventHandlers.forEach((handler, key) => {
        const [element, event] = key.split('|');
        if (element === 'document') {
          document.removeEventListener(event, handler);
        }
      });
      this.eventHandlers.clear();
      this.initialized = false;
    }

    attachDelegatedEvents() {
      // Use document-level delegation as per best practices
      const delegatedClickHandler = (e) => {
        console.log('🔍 Click detected on:', e.target, 'Classes:', e.target.className);

        // Filter button toggles - check both target and closest for img inside button
        if (e.target.matches('.filter') || e.target.closest('.filter')) {
          console.log('🎯 Filter toggle button detected');
          this.handleFilterToggle(e);
          return;
        }

        // Filter option clicks - use .closest() for better reliability
        const filterOption = e.target.closest('.filter-option');
        if (filterOption) {
          e.preventDefault();
          e.stopPropagation();
          console.log('🎯 Filter option clicked via delegation:', filterOption);
          this.handleFilterOptionClick(filterOption);
          return;
        }

        // Clear all filters button
        if (e.target.id === 'clear-all-filters-global' || e.target.closest('#clear-all-filters-global')) {
          e.preventDefault();
          e.stopPropagation();
          console.log('🧹 Clear all filters clicked');
          clearAllFilters();
          return;
        }

        // Close artist panel
        if (e.target.closest('#close-artist-panel')) {
          console.log('❌ Close artist panel clicked');
          showFiltersContent();
          return;
        }

        // Shuffle button
        if (e.target.closest('.shuffle')) {
          console.log('🎲 Shuffle button clicked');
          handleShuffle();
          return;
        }

        console.log('🔍 Click not handled by any filter');
      };

      // Hover effects for filter options
      const delegatedMouseoverHandler = (e) => {
        const filterOption = e.target.closest('.filter-option');
        if (filterOption && !filterOption.classList.contains('selected')) {
          clearTimeout(this.hoverTimeout);
          this.hoverTimeout = setTimeout(() => {
            this.applyHoverEffect(filterOption);
          }, 50);
        }
      };

      const delegatedMouseoutHandler = (e) => {
        const filterOption = e.target.closest('.filter-option');
        if (filterOption && !filterOption.classList.contains('selected')) {
          clearTimeout(this.hoverTimeout);
          this.removeHoverEffect(filterOption);
        }
      };

      // Attach delegated events
      document.addEventListener('click', delegatedClickHandler);
      document.addEventListener('mouseover', delegatedMouseoverHandler);
      document.addEventListener('mouseout', delegatedMouseoutHandler);

      // Store handlers for cleanup
      this.eventHandlers.set('document|click', delegatedClickHandler);
      this.eventHandlers.set('document|mouseover', delegatedMouseoverHandler);
      this.eventHandlers.set('document|mouseout', delegatedMouseoutHandler);

      console.log('✅ Delegated events attached');
    }

    attachDirectEvents() {
      // Direct events for elements that exist at initialization
      console.log('✅ Direct events would go here if needed');
    }

    handleFilterToggle(e) {
      // Find the filter button (could be the target or parent if clicking on img)
      const filterButton = e.target.matches('.filter') ? e.target : e.target.closest('.filter');

      if (!filterButton) {
        console.warn('⚠️ Filter button not found');
        return;
      }

      const targetId = filterButton.dataset.target;
      console.log('🎯 Filter toggle clicked, target ID:', targetId);

      if (!targetId) {
        console.warn('⚠️ No target ID found on filter button');
        return;
      }

      const el = document.getElementById(targetId);
      if (el) {
        el.classList.toggle('hidden');
        console.log('✅ Toggled hidden class on:', targetId, 'Hidden:', el.classList.contains('hidden'));
      } else {
        console.warn('⚠️ Target element not found:', targetId);
      }
    }

    handleFilterOptionClick(element) {
      // Ensure we have valid data before processing
      if (!element || !allArtists || allArtists.length === 0) {
        console.warn('⚠️ Filter click ignored - data not ready:', {
          element: !!element,
          allArtists: allArtists ? allArtists.length : 0
        });
        return;
      }

      handleFilterClick(element);
    }

    applyHoverEffect(element) {
      const buttonSize = element.dataset.buttonSize;
      const backgroundUrl = buttonBackgrounds[buttonSize];
      if (backgroundUrl) {
        element.style.backgroundImage = `url('${backgroundUrl}')`;
        element.style.opacity = '0.5';
      }
    }

    removeHoverEffect(element) {
      element.style.backgroundImage = '';
      element.style.opacity = '1';
    }
  }

  // Global event manager instance
  let eventManager = null;

  // Initialize event manager
  function initializeEvents() {
    console.log('🎯 initializeEvents called, current eventManager:', eventManager);

    if (!eventManager) {
      console.log('🎯 Creating new EventManager...');
      eventManager = new EventManager();
    }

    console.log('🎯 Calling eventManager.init()...');
    eventManager.init();

    // Test if events are actually working
    setTimeout(() => {
      console.log('🧪 Testing click delegation after 2 seconds...');
      const testFilters = document.querySelectorAll('.filter');
      console.log('🧪 Found filter buttons:', testFilters.length);
      testFilters.forEach((filter, index) => {
        console.log(`🧪 Filter ${index}:`, filter, 'data-target:', filter.dataset.target);
      });
    }, 2000);
  }

  // Cleanup events
  function cleanupEvents() {
    if (eventManager) {
      eventManager.cleanup();
    }
  }


  
  // Cleanup function to properly remove existing map
  function cleanupMap() {
    if (window.wavmapInstance) {
      try {
        window.wavmapInstance.remove();
      } catch (e) {
      }
      window.wavmapInstance = null;
    }
  }
  
  async function initializeMap() {
    const mapContainer = document.getElementById('wavmap');
    
    if (!mapContainer) {
      return;
    }
    
    // Always cleanup existing map first
    cleanupMap();
    
    // Wait for Mapbox GL to load with retry mechanism
    let attempts = 0;
    const maxAttempts = 10;
    
    while (typeof mapboxgl === 'undefined' && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    // Check if Mapbox GL is available
    if (typeof mapboxgl === 'undefined') {
      console.error('🗺️ Mapbox GL JS not loaded after', maxAttempts, 'attempts');
      return;
    }
    
    // Use token from environment variables
    mapboxgl.accessToken = mapboxToken;
    
    try {

      // Extended Europe bounds including full Scandinavia
      const europeBounds = [
          [ -35, 30 ], // Sud-ouest : Inclut l'Atlantique et l'Afrique du Nord
          [ 60, 80 ]   // Nord-est : Inclut complètement la Scandinavie et l'Arctique
      ];

      const map = new mapboxgl.Map({
        container: 'wavmap',
        style: 'mapbox://styles/mapbox/satellite-v9',
        center: [10, 54], // Center adjusted for extended Europe
        zoom: 3.5, // Better initial zoom for extended area
        maxBounds: europeBounds,
        minZoom: 2,
        maxZoom: 18
      });
      
      // Store global instance
      window.wavmapInstance = map;
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl());
      
      // Add fullscreen control  
      map.addControl(new mapboxgl.FullscreenControl());
      
      // Load and add real artist data when map is ready
      map.on('load', async function() {
        // Log current map state
        console.log('🗺️ Map loaded!');
        console.log('📍 Initial center:', map.getCenter());
        console.log('🔍 Initial zoom:', map.getZoom());

        // Force center on extended Europe
        map.setCenter([10, 54]);
        map.setZoom(3.5);

        console.log('📍 After setCenter - Center:', map.getCenter());
        console.log('🔍 After setZoom - Zoom:', map.getZoom());

        // Fetch approved artists from API
        const artists = await loadApprovedArtists();

        if (artists.length === 0) {
          console.log('ℹ️ No artists to display on map');
          return;
        }

        console.log(`🎵 Loaded ${artists.length} artists for clustering`);
        artists.forEach((artist, i) => {
          if (i < 3) { // Log first 3 for debugging
            console.log(`Artist ${i + 1}:`, {
              name: artist.artistName,
              coords: [artist.longitude, artist.latitude],
              city: artist.city
            });
          }
        });

        // Store artists globally
        allArtists = artists;
        filteredArtists = artists; // Initialize filtered artists

        // Initialize country mapping first, then populate filter options
        initCountryMapping();

        // Populate dynamic filter options with a small delay to ensure DOM is ready
        setTimeout(() => {
          populateFilterOptions(artists);
        }, 100);

        // Log that filter options are ready
        console.log('✅ Filter options populated and ready for interaction');

        // Convert artist data to GeoJSON format with null checks
        const geojsonData = {
          type: 'FeatureCollection',
          features: artists
            .filter(artist => artist.longitude != null && artist.latitude != null)
            .map(artist => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [
                  parseFloat(artist.longitude) || 0,
                  parseFloat(artist.latitude) || 0
                ]
              },
              properties: {
                id: artist.id || '',
                artistName: artist.artistName || 'Unknown Artist',
                city: artist.city || 'Unknown City',
                country: artist.country || 'Unknown Country',
                activities: Array.isArray(artist.activities) ? artist.activities.join(', ') : '',
                genres: Array.isArray(artist.genres) ? artist.genres.join(', ') : ''
              }
            }))
        };

        // Add cluster source
        console.log('🗺️ Adding points source with', geojsonData.features.length, 'features');
        map.addSource('points', {
          type: 'geojson',
          data: geojsonData,
          cluster: true,
          clusterMaxZoom: 10,  // Reduced from 14 to 10 - clusters will break apart sooner
          clusterRadius: 30    // Reduced from 50 to 30 pixels - smaller cluster radius
        });

        // Implémentation du clustering selon le tutoriel officiel Mapbox
        console.log('✅ Points source added, adding cluster layers');

        // Ajouter des layers invisibles pour le clustering, remplacés par des marqueurs HTML
        map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'points',
          filter: ['has', 'point_count'],
          paint: {
            'circle-opacity': 0,  // Invisible
            'circle-radius': 0    // Invisible
          }
        });

        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'points',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-opacity': 0,  // Invisible
            'circle-radius': 0    // Invisible
          }
        });

        // Système hybride : clustering Mapbox + marqueurs HTML personnalisés
        const allMarkers = [];

        // Manual clustering function for initial render
        function generateManualClusters() {
          console.log('🔧 Generating manual clusters...');

          // Simple distance-based clustering
          const clustered = [];
          const clusterRadius = 40; // pixels - reduced from 80 to match smaller clusters
          const processed = new Set();

          filteredArtists.forEach((artist, index) => {
            if (processed.has(index) || artist.longitude == null || artist.latitude == null) return;

            const artistCoords = [parseFloat(artist.longitude), parseFloat(artist.latitude)];
            const cluster = {
              coordinates: artistCoords,
              artists: [artist],
              indices: [index],
              allCoords: [artistCoords] // Track all coordinates for centroid calculation
            };

            // Find nearby artists for clustering
            filteredArtists.forEach((otherArtist, otherIndex) => {
              if (otherIndex === index || processed.has(otherIndex)) return;
              if (otherArtist.longitude == null || otherArtist.latitude == null) return;

              const otherCoords = [parseFloat(otherArtist.longitude), parseFloat(otherArtist.latitude)];

              // Calculate pixel distance approximation
              const lngDiff = Math.abs(artistCoords[0] - otherCoords[0]) * Math.cos(artistCoords[1] * Math.PI / 180);
              const latDiff = Math.abs(artistCoords[1] - otherCoords[1]);
              const pixelDistance = Math.sqrt(lngDiff * lngDiff + latDiff * latDiff) * 100000; // rough conversion

              if (pixelDistance < clusterRadius) {
                cluster.artists.push(otherArtist);
                cluster.indices.push(otherIndex);
                cluster.allCoords.push(otherCoords); // Add coordinates to list
                processed.add(otherIndex);
              }
            });

            // Calculate centroid (geometric center) of all points in the cluster
            if (cluster.allCoords.length > 1) {
              const avgLng = cluster.allCoords.reduce((sum, coord) => sum + coord[0], 0) / cluster.allCoords.length;
              const avgLat = cluster.allCoords.reduce((sum, coord) => sum + coord[1], 0) / cluster.allCoords.length;
              cluster.coordinates = [avgLng, avgLat];
            }

            processed.add(index);
            clustered.push(cluster);
          });

          console.log('🔧 Generated', clustered.length, 'manual clusters');

          // Create markers for each cluster
          clustered.forEach(cluster => {
            if (cluster.artists.length === 1) {
              // Single point
              const artist = cluster.artists[0];
              const markerElement = document.createElement('div');
              markerElement.className = 'red-marker';
              markerElement.style.width = '16px';
              markerElement.style.height = '16px';
              markerElement.style.backgroundColor = '#E92C0F';
              markerElement.style.borderRadius = '50%';
              markerElement.style.cursor = 'pointer';
              markerElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

              markerElement.addEventListener('click', () => {
                showArtistDetail(artist);
              });

              const marker = new mapboxgl.Marker(markerElement)
                .setLngLat(cluster.coordinates)
                .addTo(map);

              allMarkers.push(marker);
            } else {
              // Cluster
              const pointCount = cluster.artists.length;
              const clusterStyle = getClusterStyle(pointCount);

              const clusterElement = document.createElement('div');
              clusterElement.className = 'custom-cluster';
              clusterElement.style.width = clusterStyle.size;
              clusterElement.style.height = clusterStyle.size;
              clusterElement.style.background = clusterStyle.background;
              clusterElement.style.borderRadius = '50%';
              clusterElement.style.cursor = 'pointer';
              clusterElement.style.position = 'relative';
              clusterElement.style.display = 'flex';
              clusterElement.style.alignItems = 'center';
              clusterElement.style.justifyContent = 'center';
              clusterElement.style.boxShadow = '0 3px 6px rgba(0,0,0,0.3)';

              const countLabel = document.createElement('div');
              countLabel.textContent = pointCount;
              countLabel.style.color = '#FFFFFF';
              countLabel.style.fontWeight = 'bold';
              countLabel.style.fontSize = '14px';
              countLabel.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
              clusterElement.appendChild(countLabel);

              const marker = new mapboxgl.Marker(clusterElement)
                .setLngLat(cluster.coordinates)
                .addTo(map);

              allMarkers.push(marker);
            }
          });

          console.log('✅ Manual clusters generated:', allMarkers.length, 'markers');
        }

        function getClusterStyle(pointCount) {
          if (pointCount > 2 && pointCount <= 3) {
            // Petit cluster avec gradient radial
            return {
              size: '30px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 100%)'
            };
          } else if (pointCount >= 4 && pointCount <= 5) {
            // Cluster moyen
            return {
              size: '40px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 50%, #3E44E6 100%)'
            };
          } else {
            // Gros cluster
            return {
              size: '50px',
              background: 'radial-gradient(circle, #E92C0F 0%, #E9930F 30%, #3E44E6 80%, #8FD116 100%)'
            };
          }
        }

        function addCustomMarkers() {
          // Supprimer tous les marqueurs existants
          allMarkers.forEach(marker => marker.remove());
          allMarkers.length = 0;

          console.log('🔄 Adding custom markers...');

          // Obtenir les features de clustering via queryRenderedFeatures
          const features = map.queryRenderedFeatures({ layers: ['clusters', 'unclustered-point'] });
          console.log('🔍 QueryRenderedFeatures returned:', features.length, 'features');

          // Fallback: Si pas de features ou si la source n'est pas encore rendue,
          // essayer de générer les clusters manuellement
          if (features.length === 0) {
            console.log('⚠️ No features from queryRenderedFeatures, trying manual approach...');

            // Try to get clusters directly from the source
            const source = map.getSource('points');
            if (source && source._data) {
              console.log('📊 Using source data directly...');
              // Generate clusters manually for initial render
              generateManualClusters();
            } else {
              console.log('📍 Showing individual points as fallback...');
              // Show individual points as fallback
              filteredArtists.forEach(artist => {
                if (artist.longitude != null && artist.latitude != null) {
                  const coordinates = [parseFloat(artist.longitude), parseFloat(artist.latitude)];

                  // Créer un rond rouge simple
                  const markerElement = document.createElement('div');
                  markerElement.className = 'red-marker';
                  markerElement.style.width = '16px';
                  markerElement.style.height = '16px';
                  markerElement.style.backgroundColor = '#E92C0F';
                  markerElement.style.borderRadius = '50%';
                  markerElement.style.cursor = 'pointer';
                  markerElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

                  // Add click event to show artist in filters container
                  markerElement.addEventListener('click', () => {
                    showArtistDetail(artist);
                  });

                  const marker = new mapboxgl.Marker(markerElement)
                    .setLngLat(coordinates)
                    .addTo(map);

                  allMarkers.push(marker);
                }
              });
            }
          } else {
            // Utiliser les features de clustering
            features.forEach(feature => {
              const coordinates = feature.geometry.coordinates;
              const properties = feature.properties;

              if (properties.cluster) {
                // C'est un cluster - utiliser getClusterStyle
                const pointCount = properties.point_count;
                const clusterStyle = getClusterStyle(pointCount);

                const clusterElement = document.createElement('div');
                clusterElement.className = 'custom-cluster';
                clusterElement.style.width = clusterStyle.size;
                clusterElement.style.height = clusterStyle.size;
                clusterElement.style.background = clusterStyle.background;
                clusterElement.style.borderRadius = '50%';
                clusterElement.style.cursor = 'pointer';
                clusterElement.style.position = 'relative';
                clusterElement.style.display = 'flex';
                clusterElement.style.alignItems = 'center';
                clusterElement.style.justifyContent = 'center';
                clusterElement.style.boxShadow = '0 3px 6px rgba(0,0,0,0.3)';

                // Ajouter le nombre de points
                const countLabel = document.createElement('div');
                countLabel.textContent = pointCount;
                countLabel.style.color = '#FFFFFF';
                countLabel.style.fontWeight = 'bold';
                countLabel.style.fontSize = '14px';
                countLabel.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)';
                clusterElement.appendChild(countLabel);

                // Créer le marqueur
                const marker = new mapboxgl.Marker(clusterElement)
                  .setLngLat(coordinates)
                  .addTo(map);

                // Ajouter l'événement click pour zoomer
                clusterElement.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const clusterId = properties.cluster_id;
                  map.getSource('points').getClusterExpansionZoom(clusterId, (err, zoom) => {
                    if (err) return;
                    map.easeTo({
                      center: coordinates,
                      zoom: zoom
                    });
                  });
                });

                allMarkers.push(marker);

              } else {
                // C'est un point individuel
                const markerElement = document.createElement('div');
                markerElement.className = 'red-marker';
                markerElement.style.width = '16px';
                markerElement.style.height = '16px';
                markerElement.style.backgroundColor = '#E92C0F';
                markerElement.style.borderRadius = '50%';
                markerElement.style.cursor = 'pointer';
                markerElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';

                // Add click event to show artist in filters container
                markerElement.addEventListener('click', () => {
                  // Find full artist data from allArtists array
                  const fullArtist = allArtists.find(a => a.id === properties.id);
                  if (fullArtist) {
                    showArtistDetail(fullArtist);
                  } else {
                    // Fallback with basic data
                    const artistData = {
                      id: properties.id,
                      artistName: properties.artistName,
                      city: properties.city,
                      country: properties.country,
                      activities: properties.activities ? properties.activities.split(', ') : [],
                      genres: properties.genres ? properties.genres.split(', ') : []
                    };
                    showArtistDetail(artistData);
                  }
                });

                const marker = new mapboxgl.Marker(markerElement)
                  .setLngLat(coordinates)
                  .addTo(map);

                allMarkers.push(marker);
              }
            });
          }

          console.log(`🎯 Ajouté ${allMarkers.length} marqueurs (${features.length} features détectées)`);
        }

        // Force initial render then add markers
        console.log('🗺️ Forcing initial map render...');

        // Immediately try to generate manual clusters
        console.log('🚀 Generating immediate clusters...');
        generateManualClusters();

        // Wait for the map to be fully loaded and ready
        map.once('idle', () => {
          console.log('🗺️ Map is idle, adding markers...');
          addCustomMarkers();
        });

        // Mettre à jour les marqueurs lors des changements de vue
        map.on('zoomend', addCustomMarkers);
        map.on('moveend', addCustomMarkers);

        // Add click handler to get coordinates easily
        map.on('click', function(e) {
          const coords = e.lngLat;
          console.log('🎯 Clicked coordinates:');
          console.log(`   Longitude: ${coords.lng.toFixed(4)}`);
          console.log(`   Latitude: ${coords.lat.toFixed(4)}`);
          console.log(`   Array format: [${coords.lng.toFixed(4)}, ${coords.lat.toFixed(4)}]`);
        });
      });

      map.on('error', function(e) {
        console.error('🗺️ Mapbox error:', e);
      });
      
    } catch (error) {
      console.error('🗺️ Error initializing Mapbox:', error);
    }
  }
  
  // Permanent event delegation - cannot be overridden
  let permanentEventsAttached = false;

  function attachPermanentEvents() {
    if (permanentEventsAttached) {
      console.log('🔒 Permanent events already attached');
      return;
    }

    console.log('🔒 Attaching PERMANENT event delegation...');

    // Single permanent event listener that cannot be overridden
    document.addEventListener('click', function permanentClickHandler(e) {
      console.log('🔒 PERMANENT click handler triggered:', e.target);

      // Filter toggle buttons
      const filterButton = e.target.closest('.filter');
      if (filterButton) {
        console.log('🔒 PERMANENT filter toggle:', filterButton.dataset.target);
        const targetId = filterButton.dataset.target;
        const el = document.getElementById(targetId);
        if (el) {
          el.classList.toggle('hidden');
          console.log('🔒 Toggled', targetId, 'hidden:', el.classList.contains('hidden'));
        }
        return;
      }

      // Filter options
      const filterOption = e.target.closest('.filter-option');
      if (filterOption && typeof allArtists !== 'undefined' && allArtists && allArtists.length > 0) {
        console.log('🔒 PERMANENT filter option:', filterOption);
        e.preventDefault();
        e.stopPropagation();
        handleFilterClick(filterOption);
        return;
      }

      // Clear all filters
      if (e.target.id === 'clear-all-filters-global' || e.target.closest('#clear-all-filters-global')) {
        console.log('🔒 PERMANENT clear filters');
        clearAllFilters();
        return;
      }

      // Close artist panel
      if (e.target.closest('#close-artist-panel')) {
        console.log('🔒 PERMANENT close artist panel');
        showFiltersContent();
        return;
      }

      // Shuffle button
      if (e.target.closest('.shuffle')) {
        console.log('🔒 PERMANENT shuffle button clicked');
        handleShuffle();
        return;
      }

    }, true); // Use capture phase to ensure it runs first

    permanentEventsAttached = true;
    console.log('✅ PERMANENT events attached and locked');
  }

  // Main application initialization - always fresh start
  let isInitializing = false;
  function initializeApp() {
    console.log('🚀 Initializing application...');

    // Prevent multiple simultaneous initializations
    if (isInitializing) {
      console.log('⏳ Already initializing, skipping...');
      return;
    }

    // Always attach permanent events (they're idempotent)
    attachPermanentEvents();

    // Always do full initialization for reliability
    console.log('🆕 Full initialization...');
    isInitializing = true;

    initializeMap().then(() => {
      isInitializing = false;
      console.log('✅ Initialization complete');
    }).catch(error => {
      console.error('🗺️ Map initialization failed:', error);
      isInitializing = false;
    });
  }

  // Full cleanup function - always clean everything for reliability
  function cleanupApp() {
    console.log('🧹 Full cleanup - removing everything...');

    // Reset all initialization flags
    isInitializing = false;
    permanentEventsAttached = false;

    // Clear data
    if (typeof allArtists !== 'undefined') allArtists = [];
    if (typeof filteredArtists !== 'undefined') filteredArtists = [];

    // Cleanup map and events
    cleanupEvents();
    cleanupMap();

    console.log('✅ Cleanup complete');
  }

  // IMMEDIATE attachment of permanent events - before everything else
  attachPermanentEvents();

  // Astro lifecycle management - proper order for SSR + View Transitions

  // Initial load
  document.addEventListener('DOMContentLoaded', initializeApp);

  // Astro page load (includes first load and View Transitions)
  document.addEventListener('astro:page-load', initializeApp);

  // Before page transition - full cleanup for reliability
  document.addEventListener('astro:before-swap', cleanupApp);

  // After page transition - reinitialize
  document.addEventListener('astro:after-swap', initializeApp);

  // Fallback for immediate execution if DOM is already ready
  if (document.readyState === 'loading') {
    // DOM not ready yet, event listeners will handle it
  } else {
    // DOM is already ready, initialize immediately
    setTimeout(initializeApp, 10);
  }
  
</script>

<style>
  .map-container {
    width: 100%;
    margin: 0 auto;
    display: flex;
    color: black;
    padding: 1rem;
    height: calc(100vh - var(--navbar-height, 80px));
    box-sizing: border-box;
  }

  .artist-content {
    height: 100%;
    width: 100%;
    background: linear-gradient(
        to right, /* Direction changée vers la droite */
        #8FD116,
        #3E44E6 50%,
        #E9930F 80%,
        #E92C0F 100%
      );
  }


  /* Artist name */
  .artist-name {
    font-size: 24px;
    font-weight: 900;
    text-transform: uppercase;
    margin-bottom: 0.5rem;
  }

  /* Pronouns */
  .artist-pronouns-container {
    text-align: center;
    margin-bottom: 1rem;
  }

  .artist-pronouns {
    font-size: 0.9rem;
    font-weight: 600;
    color: #555;
    margin: 0.25rem 0;
    font-style: italic;
  }

  /* Artist location */
  .artist-location {
    font-size: 1.2rem;
    font-weight: 800;
    text-align: center;
    margin: 0 0 1.5rem 0;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* Artist bio */
  .artist-bio {
    margin: 1.5rem 0;
    text-align: justify;
    line-height: 1.6;
  }

  .artist-bio p {
    margin: 0;
    font-size: 0.95rem;
    color: #000;
    font-weight: 700;
  }

  /* Separator line */
  .separator-line {
    margin: 2rem 0;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .separator-line img {
    width: 100%;
    height: auto;
    max-width: 400px;
  }

  .separator-bottom img {
    transform: rotate(180deg);
  }

  /* Social media links */
  .social-media-links {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 2rem 0;
    font-size: 1.5rem;
    font-weight: 700;
    color: #000;
    letter-spacing: 2px;
  }

  .social-link {
    cursor: pointer;
    transition: color 0.2s ease;
  }

  .social-link:hover:not(.disabled) {
    color: #000;
  }

  .social-link.disabled {
    color: #ccc !important;
    cursor: default !important;
    opacity: 0.5;
  }

  .separator {
    margin: 0 1rem;
    font-size: 1.2rem;
  }

  /* Tags lines */
  .tags-line {
    margin: 1rem 0;
    text-align: center;
  }

  .tags-inline {
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    font-weight: 700;
    gap: 6px;
  }

  .tag-inline {
    font-size: 0.9rem;
    color: #000;
    padding: 0;
    margin: 0;
  }

  .tag-separator {
    margin: 0 0.5rem;
    font-size: 0.9rem;
    color: #000;
    font-weight: 900;
  }

  /* Section titles */
  .section-title {
    font-size: 1.1rem;
    font-weight: 800;
    color: #000;
    text-transform: uppercase;
    margin: 1.5rem 0 0.8rem 0;
    letter-spacing: 0.5px;
  }

  /* Social topics */
  .social-topics-container, .themes-container, .club-politics-container {
    margin: 1.5rem 0;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    display: block !important;
  }

  .social-topics-container.hidden, .themes-container.hidden, .club-politics-container.hidden {
    display: none !important;
  }

  .topics-content {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .topic-tag {
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.3rem 0.6rem;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: capitalize;
  }

  /* Themes and club politics content */
  .themes-content, .club-politics-content {
    font-size: 0.95rem;
    line-height: 1.6;
    color: #333;
    margin: 0;
    text-align: justify;
  }

  .filters-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    text-align: left;
    align-items: flex-start;
    width: 30%;
    flex-shrink: 0;
    height: 100%;
    overflow-y: auto;
  }

  .filters-content {
    padding-left: 2rem;
    height: 100%;
    overflow-y: auto;
  }

  /* Close hover button */
  .close-hover-btn {
    position: relative;
    cursor: pointer;
    margin: 0 auto 1rem auto;
    width: fit-content;
    display: flex;
    justify-content: center;
  }

  .close-btn-normal,
  .close-btn-hover {
    height: 30px;
    width: auto;
    display: block;
  }

  .close-btn-normal {
    transition: opacity 0.2s ease;
  }

  .close-btn-hover {
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  .close-hover-btn:hover .close-btn-normal {
    opacity: 0;
  }

  .close-hover-btn:hover .close-btn-hover {
    opacity: 1;
  }

  .artist-header {
    gap: 1rem;
    display: flex;
    flex-direction: column;
  }

  .artist-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0.5rem 0 0.5rem 0;
  }

  .artist-info {
    margin-bottom: 1.5rem;
  }

  .info-section {
    margin-bottom: 1.25rem;
  }

  .info-section h3 {
    font-size: 1rem;
    font-weight: 600;
    color: #374151;
    margin: 0 0 0.5rem 0;
  }

  .info-section p {
    font-size: 0.9rem;
    color: #6b7280;
    margin: 0;
    line-height: 1.5;
  }

  .social-links {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .social-links a {
    display: inline-block;
    padding: 0.375rem 0.75rem;
    background: #f3f4f6;
    color: #4b5563;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .social-links a:hover {
    background: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  .artist-actions {
    padding-top: 1rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  .view-profile-btn {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .view-profile-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
  }

  .close-panel-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: #666;
    transition: all 0.2s ease;
    z-index: 11;
  }

  .close-panel-btn:hover {
    background: rgba(0, 0, 0, 0.2);
    color: #000;
  }

  .artist-detail {
    padding: 2rem;
    padding-top: 3rem;
  }

  .artist-header {
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid #e5e7eb;
  }

  .artist-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 0.5rem 0;
  }

  .artist-info {
    margin-bottom: 1.5rem;
  }

  .info-section {
    margin-bottom: 1.25rem;
  }

  .info-section h3 {
    font-size: 1rem;
    font-weight: 600;
    color: #374151;
    margin: 0 0 0.5rem 0;
  }

  .info-section p {
    font-size: 0.9rem;
    color: #6b7280;
    margin: 0;
    line-height: 1.5;
  }

  .social-links {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .social-links a {
    display: inline-block;
    padding: 0.375rem 0.75rem;
    background: #f3f4f6;
    color: #4b5563;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .social-links a:hover {
    background: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  .artist-actions {
    padding-top: 1rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  :global(.artist-detail .view-profile-btn) {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  :global(.artist-detail .view-profile-btn:hover) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
  }

  .map-container h2 {
    font-size: 2rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 1rem 0;
    text-align: center;
    background-clip: text;
    -webkit-background-clip: text;
  }

  .shuffle {
    position: absolute;
    left: 1rem;
    bottom: 1rem;
    width: 150px;
    z-index: 3;
  }

  .filter img {
    height: 50px;
  }

  .filter-wrapper {
    position: relative;
    margin-bottom: 0.5rem;
  }

  .filter-options.hidden {
    display: none;
  }

  .map-wrapper {
    flex: 1;
    position: relative;
    min-width: 0;
  }

  .map {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  /* Appliquer le filtre uniquement sur les tuiles de la carte, pas sur les marqueurs */
  .map :global(.mapboxgl-canvas-container canvas) {
    filter:
      grayscale(100%)
      contrast(100%)
      saturate(220%)
      brightness(220%)
      hue-rotate(180deg);
  }

  .map .mapboxgl-ctrl {
    filter: none;
  }

  /* Style pour les marqueurs rouges - plus besoin de protection de filtre */
  .map :global(.red-marker) {
    transition: transform 0.2s ease;
  }

  .map :global(.red-marker:hover) {
    transform: scale(1.3);
  }

  /* Style pour les clusters avec gradient */
  .map :global(.custom-cluster) {
    transition: transform 0.2s ease;
  }

  .map :global(.custom-cluster:hover) {
    transform: scale(1.1);
  }

  /* Custom popup styles */
  :global(.mapboxgl-popup-content) {
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  }

  :global(.artist-popup h3) {
    margin: 0 0 0.5rem 0;
    color: #1f2937;
    font-size: 1.1rem;
    font-weight: 600;
  }

  :global(.artist-popup p) {
    margin: 0.25rem 0;
    font-size: 0.9rem;
    color: #6b7280;
  }

  :global(.artist-popup strong) {
    color: #374151;
  }

  :global(.artist-popup .social-links) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
  }

  :global(.artist-popup .social-links a) {
    display: inline-block;
    margin: 0 0.5rem 0.25rem 0;
    color: #6366f1;
    text-decoration: none;
    font-size: 0.8rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    background-color: #f8f9ff;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .social-links a:hover) {
    background-color: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  :global(.artist-popup .popup-actions) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  :global(.artist-popup .view-profile-btn) {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .view-profile-btn:hover) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  /* Filter options styling */
  :global(.filter-option) {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.375rem 1.5rem;
    background: transparent;
    color: black;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0.125rem;
    border: 2px solid transparent;
    position: relative;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    height: 38px;
    min-height: 38px;
    min-width: fit-content;
  }

  :global(.filter-option:hover) {
    /* Remove the transform to avoid size changes */
  }

  /* Selected state with SVG background */
  :global(.filter-option.selected) {
    background-color: transparent !important;
    color: black !important;
    font-weight: 700 !important;
    text-shadow: none !important;
    opacity: 1 !important;
  }

  /* Size-specific SVG backgrounds for selected filters */

  :global(.filter-option.selected:hover) {
    filter: brightness(1.1) !important;
  }

  /* Clear filter button */
  .clear-filter-btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    background: #ef4444;
    color: white;
    border: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0.25rem 0;
  }

  .clear-filter-btn:hover {
    background: #dc2626;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
  }

  .clear-filter-btn.hidden {
    display: none;
  }

  /* Global Clear All Filters Button */
  .clear-all-filters-btn {
    display: inline-block;
    padding: 0;
    background: none;
    color: red;
    border: none;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 1rem 0;
    text-decoration: underline;
  }

  .clear-all-filters-btn:hover {
    color: darkred;
    text-decoration: underline;
  }

  .clear-all-filters-btn.hidden {
    display: none;
  }

  /* Dynamic filter options container */
  .dynamic-filter-options {
    width: 100%;
  }

  /* City filter specific styling */
  .city-filter {
    min-width: 60px;
    text-align: center;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .map-container {
      padding: 2rem 1.5rem;
      margin: 0 1rem;
    }

    .map {
      height: 400px;
    }

    .filter-option {
      font-size: 0.7rem;
      padding: 0.25rem 0.5rem;
    }

    .clear-filter-btn {
      font-size: 0.7rem;
      padding: 0.375rem 0.75rem;
    }
  }
</style>

<!-- Import Mapbox CSS and JS -->
<link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
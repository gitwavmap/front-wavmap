---
import * as m from '../paraglide/messages.js';
import { MAPBOX_ACCESS_TOKEN } from "astro:env/client";

import ShuffleBtn from '../assets/images/shuffle_btn.svg';
import CityBtn from '../assets/images/city.svg';
import CountryBtn from '../assets/images/country.svg';
import PolBtn from '../assets/images/pol.svg';
import RoleBtn from '../assets/images/role.svg';
import StyleBtn from '../assets/images/style.svg';
import BackBtn from '../assets/images/close_btn.svg';
import BackBtnBg from '../assets/images/close_bg.svg';
import HoverLink from '../components/HoverLink.astro';
import Separator from '../assets/images/separator.svg';

// Import background images for filter buttons
import CityBg from '../assets/images/city_bg.svg';
import CountryBg from '../assets/images/country_bg.svg';
import PolBg from '../assets/images/pol_bg.svg';
import RoleBg from '../assets/images/role_bg.svg';
import StyleBg from '../assets/images/style_bg.svg';

// Import SVG button backgrounds
import Btn1 from '../assets/images/btn_1.svg';
import Btn2 from '../assets/images/btn_2.svg';
import Btn3 from '../assets/images/btn_3.svg';
import Btn4 from '../assets/images/btn_4.svg';
import Btn5 from '../assets/images/btn_5.svg';
import Btn6 from '../assets/images/btn_6.svg';
import Btn7 from '../assets/images/btn_7.svg';
import Btn8 from '../assets/images/btn_8.svg';
import Btn9 from '../assets/images/btn_9.svg';
import Btn10 from '../assets/images/btn_10.svg';
import Btn11 from '../assets/images/btn_11.svg';
import Btn12 from '../assets/images/btn_12.svg';
import Btn13 from '../assets/images/btn_13.svg';
import Btn14 from '../assets/images/btn_14.svg';

// Get Mapbox token from environment variables
const mapboxToken = MAPBOX_ACCESS_TOKEN;

const filters = [
  { id: "country", label: "Country", icon: CountryBtn, hoverIcon: CountryBg, options: [] }, // Populated dynamically
  { id: "city", label: "City", icon: CityBtn, hoverIcon: CityBg, options: [] }, // Populated dynamically
  { id: "style", label: "Style", icon: StyleBtn, hoverIcon: StyleBg, options: ["Jazz", "HipHop", "Techno"] },
  { id: "role", label: "Role", icon: RoleBtn, hoverIcon: RoleBg, options: ["DJ", "Producer", "Singer"] },
  { id: "pol", label: "Pol", icon: PolBtn, hoverIcon: PolBg, options: ["Option A", "Option B", "Option C"] },
];

let allArtists = []; // Store all artists for filtering
let selectedFilters = { cities: [], countries: [], styles: [], roles: [], pol: [] }; // Track selected filters
---

<div class="map-container" transition:persist="false">
  <div class="map-wrapper">
    <div id="wavmap" class="map"></div>
    <button class="shuffle">
      <img src={ShuffleBtn.src} alt="shuffle" />
    </button>
  </div>
    <div class="filters-container">
      <!-- Filters Content (shown by default) -->
      <div id="filters-content" class="filters-content">
        {filters.map(filter => (
          <div key={filter.id} class="filter-wrapper">
            <button
              class="filter filter-hover-btn"
              data-target={`filter-${filter.id}`}
              data-normal-src={filter.icon.src}
              data-hover-src={filter.hoverIcon.src}
            >
              <img src={filter.icon.src} alt={filter.label} class="filter-button-image" />
            </button>

            <!-- Ligne d'options cach√©e par d√©faut -->
            <div id={`filter-${filter.id}`} class="filter-options hidden mt-2 flex flex-wrap gap-2">
              <div id={`${filter.id}-dynamic-options`} class="dynamic-filter-options flex flex-wrap gap-2">
                <!-- Options will be populated dynamically by JavaScript -->
              </div>
            </div>
          </div>
        ))}

        <!-- Global Clear All Filters Button -->
        <button id="clear-all-filters-global" class="clear-all-filters-btn hidden">
          Clear All Filters
        </button>
      </div>

      <!-- Artist Detail Content (hidden by default) -->
      <div id="artist-content" class="artist-content hidden">
        <div style={{backgroundColor: "white", padding: "1rem", height: "calc(100% - 2rem)", margin: "1rem", boxSizing: "border-box", overflowY: "auto"}}>

          <div id="close-artist-panel" class="close-hover-btn">
            <img src={BackBtn.src} alt="Close" class="close-btn-normal" />
            <img src={BackBtnBg.src} alt="Close" class="close-btn-hover" />
          </div>


          <!-- Artist Name -->
          <h2 id="artist-name-display" class="artist-name">Artist Name</h2>

          <!-- Pronouns -->
          <div id="artist-pronouns-container" class="artist-pronouns-container hidden">
            <p id="artist-pronouns" class="artist-pronouns"></p>
          </div>

          <!-- Location -->
          <h3 id="artist-location" class="artist-location">CITY - COUNTRY</h3>

          <!-- Bio -->
          <div class="artist-bio">
            <p id="artist-bio">Artist bio will appear here...</p>
          </div>

          <!-- Decorative line -->
          <div class="separator-line">
            <img src={Separator.src} alt="Separator" />
          </div>

          <!-- Social Media Links -->
          <div class="social-media-links">
            <span id="website-link" class="social-link">WS</span>
            <span class="separator">|</span>
            <span id="bandcamp-link" class="social-link">BC</span>
            <span class="separator">|</span>
            <span id="soundcloud-link" class="social-link">SC</span>
            <span class="separator">|</span>
            <span id="instagram-link" class="social-link">IN</span>
            <span class="separator">|</span>
            <span id="subvert-link" class="social-link">SV</span>
            <span class="separator">|</span>
            <span id="tiktok-link" class="social-link">TT</span>
            <span class="separator">|</span>
            <span id="youtube-link" class="social-link">YT</span>
            <span class="separator">|</span>
            <span id="email-link" class="social-link">EM</span>
          </div>

          <!-- Activities & Genres Tags -->
          <div class="tags-line">
            <div id="all-tags" class="tags-inline">
              <!-- Tags will be populated dynamically -->
            </div>
          </div>

          <!-- Decorative line -->
          <div class="separator-line separator-bottom">
            <img src={Separator.src} alt="Separator" />
          </div>

          <!-- Social/Political Topics -->
          <div id="social-topics-container" class="social-topics-container hidden">
            <h4 class="section-title">Social & Political Engagement</h4>
            <div id="social-topics" class="topics-content">
              <!-- Social topics will be populated dynamically -->
            </div>
          </div>

          <!-- Themes & Development -->
          <div id="themes-container" class="themes-container hidden">
            <h4 class="section-title">Themes & Development</h4>
            <p id="themes-development-display" class="themes-content"></p>
          </div>

          <!-- Club Politics / Political Approach -->
          <div id="club-politics-container" class="club-politics-container hidden">
            <h4 class="section-title">Political Approach</h4>
            <p id="club-politics-display" class="club-politics-content"></p>
          </div>

        </div>
      </div>
    </div>
</div>

<script define:vars={{ mapboxToken, Btn1, Btn2, Btn3, Btn4, Btn5, Btn6, Btn7, Btn8, Btn9, Btn10, Btn11, Btn12, Btn13, Btn14 }}>
  // Import cities data to get country name mapping
  let countryMapping = {};

  // SVG background assets
  const buttonBackgrounds = {
    1: Btn1.src,
    2: Btn2.src,
    3: Btn3.src,
    4: Btn4.src,
    5: Btn5.src,
    6: Btn6.src,
    7: Btn7.src,
    8: Btn8.src,
    9: Btn9.src,
    10: Btn10.src,
    11: Btn11.src,
    12: Btn12.src,
    13: Btn13.src,
    14: Btn14.src
  };

  // Cache for selected SVGs (with black fill)
  const buttonBackgroundsSelected = {};

  // Pre-load all SVGs with black fill at startup
  async function preloadSelectedSVGs() {
    const promises = Object.entries(buttonBackgrounds).map(async ([size, url]) => {
      try {
        const response = await fetch(url);
        const svgText = await response.text();
        // Add fill="black" to the path
        const modifiedSvg = svgText.replace(/<path /g, '<path fill="black" ');
        const blob = new Blob([modifiedSvg], { type: 'image/svg+xml' });
        const objectUrl = URL.createObjectURL(blob);
        buttonBackgroundsSelected[size] = objectUrl;
      } catch (err) {
        console.error(`Error loading SVG ${size}:`, err);
      }
    });
    await Promise.all(promises);
    console.log('‚úÖ All selected SVGs preloaded');
  }

  // Call preload immediately
  preloadSelectedSVGs();

  // Function to determine button background size based on text length
  function getButtonSize(text) {
    const length = text.length;
    if (length <= 3) return 4;        // Very short: btn_4.svg
    if (length <= 5) return 5;        // Short: btn_5.svg
    if (length <= 8) return 6;        // Medium-short: btn_6.svg
    if (length <= 12) return 7;       // Medium: btn_7.svg
    if (length <= 16) return 8;       // Medium-long: btn_8.svg
    if (length <= 20) return 9;       // Long: btn_9.svg
    if (length <= 24) return 10;      // Very long: btn_10.svg
    if (length <= 28) return 11;      // Extra long: btn_11.svg
    if (length <= 32) return 12;      // btn_12.svg
    if (length <= 36) return 13;      // btn_13.svg
    return 14;                        // Maximum: btn_14.svg (> 36 characters)
  }

  // Initialize country mapping directly (based on european-cities.json data)
  function initCountryMapping() {
    countryMapping = {
      'AT': 'Austria',
      'BE': 'Belgium',
      'CH': 'Switzerland',
      'CZ': 'Czech Republic',
      'DE': 'Germany',
      'DK': 'Denmark',
      'ES': 'Spain',
      'FI': 'Finland',
      'FR': 'France',
      'GB': 'United Kingdom',
      'GR': 'Greece',
      'HU': 'Hungary',
      'IE': 'Ireland',
      'IT': 'Italy',
      'NL': 'Netherlands',
      'NO': 'Norway',
      'PL': 'Poland',
      'PT': 'Portugal',
      'RO': 'Romania',
      'SE': 'Sweden'
    };

    console.log('üó∫Ô∏è Initialized country mapping:', countryMapping);
    return countryMapping;
  }

  // Function to get country display name from country code
  function getCountryDisplayName(countryCode) {
    return countryMapping[countryCode] || countryCode;
  }

  // Mapping for social topics values to display labels
  function getSocialTopicLabel(value) {
    const socialTopicsLabels = {
      'queerrights': 'Queer Rights',
      'flintarepresentation': 'FLINTA Representation',
      'genderequality': 'Gender Equality',
      'anti-racism': 'Anti-Racism',
      'decolonialism': 'Decolonialism',
      'acccessibilityforpeoplewithdisabilities': 'Accessibility For People With Disabilities',
      'economicequalityclasssolidarity': 'Economic Equality & Class Solidarity',
      'climatejustice': 'Climate Justice',
      'geographicmarginalization': 'Geographic Marginalization'
    };

    // Return mapped label if exists, otherwise format the value automatically
    if (socialTopicsLabels[value]) {
      return socialTopicsLabels[value];
    }

    // Fallback formatting for club politics or other free text
    return value
      .replace(/([a-z])([A-Z])/g, '$1 $2') // camelCase to spaces
      .replace(/[_-]/g, ' ') // underscores/dashes to spaces
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ')
      .replace(/\s+/g, ' ')
      .trim();
  }

  // Filter management variables - factorized structure
  let selectedFilters = {
    cities: [],
    countries: [],
    activities: [], // roles
    genres: [], // styles
    socialTopics: [], // political topics (legacy)
    political: [] // combined political topics
  };
  let filteredArtists = [];
  let currentArtistMarkers = []; // Store current markers for filtering


  // Helper function to extract unique values from arrays in artist data
  function extractUniqueValues(artists, field, isArray = false) {
    const values = new Set();

    artists.forEach(artist => {
      if (isArray && Array.isArray(artist[field])) {
        artist[field].forEach(item => {
          if (item && item.trim()) values.add(item.trim());
        });
      } else if (!isArray && artist[field] && artist[field].trim()) {
        values.add(artist[field].trim());
      }
    });

    return [...values].sort();
  }

  // Special function to extract political topics from both socialTopics and clubPolitics
  function extractPoliticalTopics(artists) {
    const values = new Set();
    artists.forEach(artist => {
      // Add social topics (array)
      if (Array.isArray(artist.socialTopics)) {
        artist.socialTopics.forEach(topic => {
          if (topic && topic.trim()) values.add(topic.trim());
        });
      }
      // Add club politics (string)
      if (artist.clubPolitics && artist.clubPolitics.trim()) {
        values.add(artist.clubPolitics.trim());
      }
    });
    return [...values].sort();
  }

  // Function to populate dynamic filter options - factorized and reactive
  function populateFilterOptions(artists, selectedCountries = []) {
    console.log('üîß Starting to populate filter options with', artists.length, 'artists');
    console.log('üåç Selected countries:', selectedCountries);

    // Filter artists by selected countries if any
    let artistsForCityFilter = artists;
    if (selectedCountries.length > 0) {
      artistsForCityFilter = artists.filter(artist =>
        selectedCountries.includes(artist.country)
      );
      console.log(`üèôÔ∏è Filtered to ${artistsForCityFilter.length} artists from selected countries`);
    }

    // Define filter mappings - what data to extract and how to display it
    const filterConfigs = {
      'country': {
        data: extractUniqueValues(artists, 'country'),
        displayTransform: getCountryDisplayName, // Transform codes to names
        filterType: 'country',
        cssClass: 'country-filter'
      },
      'city': {
        data: extractUniqueValues(artistsForCityFilter, 'city'), // Use filtered artists
        displayTransform: null, // No transformation needed
        filterType: 'city',
        cssClass: 'city-filter'
      },
      'role': {
        data: extractUniqueValues(artists, 'activities', true), // Array field
        displayTransform: null,
        filterType: 'activities',
        cssClass: 'activities-filter'
      },
      'style': {
        data: extractUniqueValues(artists, 'genres', true), // Array field
        displayTransform: null,
        filterType: 'genres',
        cssClass: 'genres-filter'
      },
      'pol': {
        data: extractPoliticalTopics(artists), // Combined social topics and club politics
        displayTransform: getSocialTopicLabel, // Transform values to readable labels
        filterType: 'political',
        cssClass: 'political-filter'
      }
    };

    // Populate each filter type
    Object.entries(filterConfigs).forEach(([filterId, config]) => {
      const container = document.getElementById(`${filterId}-dynamic-options`);
      console.log(`üîç Looking for container: ${filterId}-dynamic-options`, container ? '‚úÖ Found' : '‚ùå Not found');

      if (container && config.data.length > 0) {
        const optionsHTML = config.data.map(value => {
          const displayValue = config.displayTransform ? config.displayTransform(value) : value;
          const buttonSize = getButtonSize(displayValue);

          // Check if this option was previously selected
          const isSelected = document.querySelector(
            `.filter-option[data-filter-type="${config.filterType}"][data-value="${value}"].selected`
          );
          const selectedClass = isSelected ? ' selected' : '';
          const selectedBackgroundUrl = buttonBackgroundsSelected[buttonSize];
          const backgroundStyle = isSelected && selectedBackgroundUrl
            ? `style="background-image: url('${selectedBackgroundUrl}'); background-size: contain; background-repeat: no-repeat; background-position: center; opacity: 1;"`
            : '';

          return `<span class="filter-option ${config.cssClass}${selectedClass}" data-filter-type="${config.filterType}" data-value="${value}" data-button-size="${buttonSize}" ${backgroundStyle}>${displayValue}</span>`;
        }).join('');

        container.innerHTML = optionsHTML;
        console.log(`üè∑Ô∏è Populated ${filterId} filter with ${config.data.length} options:`, config.data.slice(0, 5));
      } else if (!container) {
        console.warn(`‚ö†Ô∏è Container not found for ${filterId}`);
      } else if (config.data.length === 0) {
        console.warn(`‚ö†Ô∏è No data for ${filterId}`);
      }
    });

    console.log('‚úÖ Filter population complete');
  }

  // Function to handle filter selection - factorized
  function handleFilterClick(element) {
    // Ensure we have valid data and the map is ready
    if (!element || !allArtists || allArtists.length === 0) {
      console.warn('‚ö†Ô∏è Filter click ignored - data not ready:', {
        element: !!element,
        allArtists: allArtists ? allArtists.length : 0
      });
      return;
    }

    const filterType = element.dataset.filterType;
    const value = element.dataset.value;
    const isSelected = element.classList.contains('selected');

    console.log('üéØ Filter clicked:', { filterType, value, isSelected });

    // Map filter types to selectedFilters keys
    const filterTypeMap = {
      'city': 'cities',
      'country': 'countries',
      'activities': 'activities',
      'genres': 'genres',
      'socialTopics': 'socialTopics',
      'political': 'political'
    };

    const filterKey = filterTypeMap[filterType];
    if (!filterKey) {
      console.warn('‚ö†Ô∏è Unknown filter type:', filterType);
      return;
    }

    // Toggle selection
    if (isSelected) {
      // Deselect
      element.classList.remove('selected');
      element.style.backgroundImage = '';
      element.style.backgroundColor = '';
      element.style.opacity = '1';
      selectedFilters[filterKey] = selectedFilters[filterKey].filter(item => item !== value);
      console.log(`‚ùå Deselected ${filterType}:`, value);
    } else {
      // Select - apply preloaded SVG with black fill
      element.classList.add('selected');
      const buttonSize = element.dataset.buttonSize;
      const selectedBackgroundUrl = buttonBackgroundsSelected[buttonSize];
      if (selectedBackgroundUrl) {
        element.style.backgroundImage = `url('${selectedBackgroundUrl}')`;
        element.style.backgroundSize = 'contain';
        element.style.backgroundRepeat = 'no-repeat';
        element.style.backgroundPosition = 'center';
        element.style.opacity = '1';
      } else {
        // Fallback while SVGs are loading
        element.style.backgroundColor = 'black';
      }
      selectedFilters[filterKey].push(value);
      console.log(`‚úÖ Selected ${filterType}:`, value);
    }

    console.log('üìä Current selections:', selectedFilters);

    // If country filter changed, update city filter options
    if (filterType === 'country') {
      console.log('üåç Country filter changed, updating city options...');
      populateFilterOptions(allArtists, selectedFilters.countries);
    }

    // Update clear filter button visibility
    updateClearFilterButton();

    // Apply filters to map
    applyFilters();
  }

  // Function to update clear filter button visibility - factorized
  function updateClearFilterButton() {
    const clearBtn = document.getElementById('clear-all-filters-global');
    if (clearBtn) {
      const hasActiveFilters = Object.values(selectedFilters).some(arr => arr.length > 0);
      if (hasActiveFilters) {
        clearBtn.classList.remove('hidden');
      } else {
        clearBtn.classList.add('hidden');
      }
    }
  }

  // Function to clear all filters - factorized
  function clearAllFilters() {
    // Reset all filter arrays
    Object.keys(selectedFilters).forEach(key => {
      selectedFilters[key] = [];
    });

    // Remove selected class from all filter elements and clear backgrounds
    document.querySelectorAll('.filter-option.selected').forEach(element => {
      element.classList.remove('selected');
      element.style.backgroundImage = '';
      element.style.opacity = '1';
    });

    console.log('üßπ All filters cleared');

    // Repopulate filter options to restore all cities (not just from selected country)
    populateFilterOptions(allArtists, []);

    // Update clear button visibility
    updateClearFilterButton();

    // Reset map to show all artists
    applyFilters();
  }

  // Function to apply filters to the map - factorized with smart AND logic
  function applyFilters() {
    const hasActiveFilters = Object.values(selectedFilters).some(arr => arr.length > 0);

    if (!hasActiveFilters) {
      // No filters active, show all artists
      filteredArtists = allArtists;
    } else {
      // Filter artists using AND logic across all active filter types
      filteredArtists = allArtists.filter(artist => {
        // City filter
        const cityMatch = selectedFilters.cities.length === 0 ||
          selectedFilters.cities.includes(artist.city);

        // Country filter
        const countryMatch = selectedFilters.countries.length === 0 ||
          selectedFilters.countries.includes(artist.country);

        // Activities/Roles filter (check if artist has ANY of the selected activities)
        const activitiesMatch = selectedFilters.activities.length === 0 ||
          (Array.isArray(artist.activities) &&
           artist.activities.some(activity => selectedFilters.activities.includes(activity)));

        // Genres/Styles filter (check if artist has ANY of the selected genres)
        const genresMatch = selectedFilters.genres.length === 0 ||
          (Array.isArray(artist.genres) &&
           artist.genres.some(genre => selectedFilters.genres.includes(genre)));

        // Political filter (check if artist has ANY of the selected political topics)
        const politicalMatch = selectedFilters.political.length === 0 ||
          // Check both socialTopics array and clubPolitics string
          (Array.isArray(artist.socialTopics) &&
           artist.socialTopics.some(topic => selectedFilters.political.includes(topic))) ||
          (artist.clubPolitics && selectedFilters.political.includes(artist.clubPolitics));

        // All active filter conditions must be true (AND logic)
        return cityMatch && countryMatch && activitiesMatch && genresMatch && politicalMatch;
      });
    }

    console.log(`üîç Filtering result: ${filteredArtists.length} of ${allArtists.length} artists match filters`);

    // Update map markers
    updateMapMarkers();
  }

  // Function to update map markers based on filtered artists
  function updateMapMarkers() {
    if (!window.wavmapInstance) {
      console.log('‚ö†Ô∏è Map instance not available');
      return;
    }

    const map = window.wavmapInstance;

    console.log('üó∫Ô∏è Updating map with filtered artists:', filteredArtists.length);

    // Update the map source data with filtered artists
    const geojsonData = {
      type: 'FeatureCollection',
      features: filteredArtists
        .filter(artist => artist.longitude != null && artist.latitude != null)
        .map(artist => ({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: [
              parseFloat(artist.longitude) || 0,
              parseFloat(artist.latitude) || 0
            ]
          },
          properties: {
            id: artist.id || '',
            artistName: artist.artistName || 'Unknown Artist',
            city: artist.city || 'Unknown City',
            country: artist.country || 'Unknown Country',
            activities: Array.isArray(artist.activities) ? artist.activities.join(', ') : '',
            genres: Array.isArray(artist.genres) ? artist.genres.join(', ') : ''
          }
        }))
    };

    console.log('üìç GeoJSON features count:', geojsonData.features.length);

    // Update map source
    if (map.getSource('points')) {
      map.getSource('points').setData(geojsonData);
      console.log('‚úÖ Map source updated successfully');
      // No need to force refresh - the sourcedata event will handle it
    } else {
      console.log('‚ùå Map source "points" not found');
    }

    // Build readable filter summary
    const activeFilters = [];
    Object.entries(selectedFilters).forEach(([key, values]) => {
      if (values.length > 0) {
        const displayKey = key.charAt(0).toUpperCase() + key.slice(1);
        activeFilters.push(`${displayKey}: ${values.slice(0, 3).join(', ')}${values.length > 3 ? '...' : ''}`);
      }
    });

    console.log(`üéØ Applied filters: ${activeFilters.length > 0 ? activeFilters.join(' | ') : 'None'}`);
    console.log(`üìç Showing ${filteredArtists.length} of ${allArtists.length} artists`);
  }

  // Cache configuration
  const ARTISTS_CACHE_KEY = 'wavmap_artists_cache';
  const ARTISTS_CACHE_EXPIRY_KEY = 'wavmap_artists_cache_expiry';
  const CACHE_DURATION = 10 * 60 * 1000; // 10 minutes

  function getArtistsFromCache() {
    try {
      const cachedData = localStorage.getItem(ARTISTS_CACHE_KEY);
      const cacheExpiry = localStorage.getItem(ARTISTS_CACHE_EXPIRY_KEY);

      if (cachedData && cacheExpiry && Date.now() < parseInt(cacheExpiry)) {
        console.log('‚úÖ Using cached artists data');
        return JSON.parse(cachedData);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Error reading artists cache:', error);
    }
    return null;
  }

  function saveArtistsToCache(artists) {
    try {
      localStorage.setItem(ARTISTS_CACHE_KEY, JSON.stringify(artists));
      localStorage.setItem(ARTISTS_CACHE_EXPIRY_KEY, (Date.now() + CACHE_DURATION).toString());
      console.log('üíæ Artists cached for 10 minutes');
    } catch (error) {
      console.warn('‚ö†Ô∏è Error saving artists to cache:', error);
    }
  }

  // Fetch real artist data from Directus API with smart caching
  async function loadApprovedArtists() {
    try {
      // Try cache first
      const cachedArtists = getArtistsFromCache();
      if (cachedArtists) {
        console.log('üö® DATA SOURCE: CACHED DATA');
        return cachedArtists;
      }

      console.log('üîç Fetching artists from API...');
      console.log('üîç Current timestamp:', new Date().toISOString());
      const response = await fetch('/api/artists/approved?_t=' + Date.now());
      const data = await response.json();

      console.log('üîç API Response:', data);
      console.log('üîç API Response details:');
      console.log('  - Success:', data.success);
      console.log('  - Count:', data.count);
      console.log('  - Artists array:', data.artists);

      if (data.artists && data.artists.length > 0) {
        data.artists.forEach((artist, index) => {
          console.log(`üéµ Artist ${index + 1}:`, {
            id: artist.id,
            name: artist.artistName,
            city: artist.city,
            country: artist.country,
            lat: artist.latitude,
            lng: artist.longitude,
            activities: artist.activities,
            genres: artist.genres?.slice(0, 3)
          });
        });
      }

      if (data.success && data.artists && data.artists.length > 0) {
        // Save to cache
        saveArtistsToCache(data.artists);

        console.log('‚úÖ Using fresh API data:', data.artists.length, 'artists');
        console.log('üö® DATA SOURCE: FRESH API DATA');
        return data.artists;
      } else {
        console.log('‚ö†Ô∏è No artists found in database');
        return [];
      }
    } catch (error) {
      console.error('üó∫Ô∏è Error loading artists:', error);
      return [];
    }
  }


  // Function to get random artist from filtered artists
  function getRandomArtist() {
    if (!filteredArtists || filteredArtists.length === 0) {
      console.log('‚ö†Ô∏è No artists available for shuffle');
      return null;
    }

    const randomIndex = Math.floor(Math.random() * filteredArtists.length);
    const randomArtist = filteredArtists[randomIndex];

    console.log('üé≤ Shuffled to random artist:', randomArtist.artistName);
    return randomArtist;
  }

  // Function to handle shuffle button click
  function handleShuffle() {
    const randomArtist = getRandomArtist();
    if (!randomArtist) return;

    // Center map on artist coordinates
    if (window.wavmapInstance && randomArtist.longitude != null && randomArtist.latitude != null) {
      const map = window.wavmapInstance;

      // Fly to the artist location with a nice animation
      map.flyTo({
        center: [parseFloat(randomArtist.longitude), parseFloat(randomArtist.latitude)],
        zoom: 12, // Zoom in to see the artist location clearly
        duration: 2000, // 2 second animation
        essential: true
      });

      // Wait for the animation to complete, then show artist detail
      setTimeout(() => {
        showArtistDetail(randomArtist);
      }, 2200); // Slightly after animation ends
    } else {
      // If no map or coordinates, just show artist detail
      showArtistDetail(randomArtist);
    }
  }

  // Functions to toggle between filters and artist content
  function showArtistDetail(artist) {
    const filtersContent = document.getElementById('filters-content');
    const artistContent = document.getElementById('artist-content');

    if (!filtersContent || !artistContent) return;

    // Hide filters, show artist details
    filtersContent.classList.add('hidden');
    artistContent.classList.remove('hidden');

    console.log('üé® Showing artist detail for:', artist.artistName);
    console.log('üîç Full artist object:', artist);
    console.log('üîç Artist keys:', Object.keys(artist));
    console.log('üîç themesDevelopment:', artist.themesDevelopment);
    console.log('üîç clubPolitics:', artist.clubPolitics);

    // Populate basic info
    const artistNameElement = document.getElementById('artist-name-display');
    console.log('üìù Setting artist name:', artist.artistName, 'Element:', artistNameElement);
    artistNameElement.textContent = artist.artistName || 'Unknown Artist';

    // Use full country name instead of code
    const countryName = getCountryDisplayName(artist.country) || artist.country || 'Unknown Country';
    document.getElementById('artist-location').textContent =
      `${(artist.city || 'Unknown City').toUpperCase()} - ${countryName.toUpperCase()}`;

    // Pronouns
    const pronounsContainer = document.getElementById('artist-pronouns-container');
    const pronounsElement = document.getElementById('artist-pronouns');

    if (artist.pronouns && artist.pronouns.trim()) {
      pronounsContainer.classList.remove('hidden');
      pronounsElement.textContent = `Pronouns: ${artist.pronouns}`;
    } else {
      pronounsContainer.classList.add('hidden');
    }


    // Set bio
    document.getElementById('artist-bio').textContent = artist.bio || 'No bio available.';

    // Handle social media links
    const websiteLink = document.getElementById('website-link');
    const bandcampLink = document.getElementById('bandcamp-link');
    const soundcloudLink = document.getElementById('soundcloud-link');
    const instagramLink = document.getElementById('instagram-link');
    const subvertLink = document.getElementById('subvert-link');
    const tiktokLink = document.getElementById('tiktok-link');
    const youtubeLink = document.getElementById('youtube-link');
    const emailLink = document.getElementById('email-link');

    // Helper function to set link state
    function setSocialLinkState(element, url, isEmail = false) {
      if (url && url.trim()) {
        if (isEmail) {
          element.onclick = () => window.location.href = `mailto:${url}`;
        } else {
          element.onclick = () => window.open(url, '_blank');
        }
        element.style.color = '#000';
        element.style.cursor = 'pointer';
        element.classList.remove('disabled');
      } else {
        element.style.color = '#ccc';
        element.style.cursor = 'default';
        element.onclick = null;
        element.classList.add('disabled');
      }
    }

    // Set all social links
    setSocialLinkState(websiteLink, artist.website);
    setSocialLinkState(bandcampLink, artist.bandcamp);
    setSocialLinkState(soundcloudLink, artist.soundcloud);
    setSocialLinkState(instagramLink, artist.instagram);
    setSocialLinkState(subvertLink, artist.subvert);
    setSocialLinkState(tiktokLink, artist.tiktok);
    setSocialLinkState(youtubeLink, artist.youtube);
    setSocialLinkState(emailLink, artist.email, true);

    // Populate ALL tags on single line
    const allTagsContainer = document.getElementById('all-tags');
    const allTags = [];

    // Add activities first
    if (artist.activities && Array.isArray(artist.activities)) {
      allTags.push(...artist.activities);
    }

    // Add genres after
    if (artist.genres && Array.isArray(artist.genres)) {
      allTags.push(...artist.genres);
    }

    if (allTags.length > 0) {
      const tagsHTML = allTags.map((tag, index) =>
        index < allTags.length - 1
          ? `<span class="tag-inline">${tag}</span><span class="tag-separator">|</span>`
          : `<span class="tag-inline">${tag}</span>`
      ).join('');
      allTagsContainer.innerHTML = tagsHTML;
    }

    // Social/Political Topics
    const socialTopicsContainer = document.getElementById('social-topics-container');
    const socialTopicsElement = document.getElementById('social-topics');

    if (artist.socialTopics && Array.isArray(artist.socialTopics) && artist.socialTopics.length > 0) {
      socialTopicsContainer.classList.remove('hidden');
      const topicsHTML = artist.socialTopics.map(topic =>
        `<span class="topic-tag">${getSocialTopicLabel(topic)}</span>`
      ).join('');
      socialTopicsElement.innerHTML = topicsHTML;
    } else {
      socialTopicsContainer.classList.add('hidden');
    }

    // Themes & Development
    const themesContainer = document.getElementById('themes-container');
    const themesElement = document.getElementById('themes-development-display');

    console.log('üé≠ Themes section - Value:', artist.themesDevelopment, 'Container:', themesContainer, 'Element:', themesElement);
    if (artist.themesDevelopment && artist.themesDevelopment.trim()) {
      console.log('‚úÖ Showing themes section');
      themesContainer.classList.remove('hidden');
      themesElement.textContent = artist.themesDevelopment;
      console.log('üìù Set themes text to:', themesElement.textContent);
    } else {
      console.log('‚ùå Hiding themes section');
      themesContainer.classList.add('hidden');
    }

    // Club Politics
    const clubPoliticsContainer = document.getElementById('club-politics-container');
    const clubPoliticsElement = document.getElementById('club-politics-display');

    console.log('üèõÔ∏è Politics section - Value:', artist.clubPolitics, 'Container:', clubPoliticsContainer, 'Element:', clubPoliticsElement);
    if (artist.clubPolitics && artist.clubPolitics.trim()) {
      console.log('‚úÖ Showing politics section');
      clubPoliticsContainer.classList.remove('hidden');
      clubPoliticsElement.textContent = artist.clubPolitics;
      console.log('üìù Set politics text to:', clubPoliticsElement.textContent);
    } else {
      console.log('‚ùå Hiding politics section');
      clubPoliticsContainer.classList.add('hidden');
    }
  }

  function showFiltersContent() {
    const filtersContent = document.getElementById('filters-content');
    const artistContent = document.getElementById('artist-content');

    if (!filtersContent || !artistContent) return;

    // Show filters, hide artist details
    filtersContent.classList.remove('hidden');
    artistContent.classList.add('hidden');
  }

  // Initialize filter button hover effects
  function initializeFilterButtonHover() {
    const filterButtons = document.querySelectorAll('.filter-hover-btn');

    filterButtons.forEach(button => {
      const img = button.querySelector('.filter-button-image');
      const normalSrc = button.dataset.normalSrc;
      const hoverSrc = button.dataset.hoverSrc;
      const targetId = button.dataset.target;

      if (!img || !normalSrc || !hoverSrc) return;

      // Preload images
      const normalImg = new Image();
      const hoverImg = new Image();
      normalImg.src = normalSrc;
      hoverImg.src = hoverSrc;

      // Function to check if section is expanded
      const isExpanded = () => {
        const filterOptions = document.getElementById(targetId);
        return filterOptions && !filterOptions.classList.contains('hidden');
      };

      // Function to update image based on state
      const updateImage = () => {
        if (isExpanded()) {
          img.src = hoverSrc;
        } else {
          img.src = normalSrc;
        }
      };

      // Hover events
      button.addEventListener('mouseenter', () => {
        img.src = hoverSrc;
      });

      button.addEventListener('mouseleave', () => {
        updateImage();
      });

      // Store update function for use in click handler
      button._updateImage = updateImage;
    });
  }

  // Simple event management
  function attachSimpleEvents() {
    console.log('üéØ Attaching events...');

    const mapContainer = document.querySelector('.map-container');
    if (!mapContainer) {
      console.warn('‚ö†Ô∏è Map container not found, skipping events');
      return;
    }

    // Main click handler
    const clickHandler = function(e) {
      // Filter toggle buttons
      const filterButton = e.target.closest('.filter');
      if (filterButton) {
        const targetId = filterButton.dataset.target;
        const filterOptions = document.getElementById(targetId);
        if (filterOptions) {
          const isOpening = filterOptions.classList.contains('hidden');
          filterOptions.classList.toggle('hidden');
          console.log('Toggle filter:', targetId);

          // Update button image based on expanded state
          if (filterButton._updateImage) {
            filterButton._updateImage();
          }

          // If opening the filter, scroll it into view within the filters container
          if (isOpening) {
            const filtersContainer = document.querySelector('.filters-container');
            const filterWrapper = filterButton.closest('.filter-wrapper');

            if (filtersContainer && filterWrapper) {
              // Calculate position of filter wrapper relative to container
              const containerRect = filtersContainer.getBoundingClientRect();
              const filterRect = filterWrapper.getBoundingClientRect();
              const scrollOffset = filterRect.top - containerRect.top + filtersContainer.scrollTop;

              // Smooth scroll to position the filter at the top of the container
              filtersContainer.scrollTo({
                top: scrollOffset - 10, // 10px offset from top for visual breathing room
                behavior: 'smooth'
              });
            }
          }
        }
        return;
      }

      // Filter option clicks
      const filterOption = e.target.closest('.filter-option');
      if (filterOption && allArtists && allArtists.length > 0) {
        handleFilterClick(filterOption);
        return;
      }

      // Clear all filters
      if (e.target.id === 'clear-all-filters-global') {
        clearAllFilters();
        return;
      }

      // Close artist panel
      if (e.target.closest('#close-artist-panel')) {
        showFiltersContent();
        return;
      }

      // Shuffle button
      if (e.target.closest('.shuffle')) {
        handleShuffle();
        return;
      }
    };

    // Hover effects for filter options
    const mouseoverHandler = function(e) {
      const filterOption = e.target.closest('.filter-option');
      if (filterOption && !filterOption.classList.contains('selected')) {
        const buttonSize = filterOption.dataset.buttonSize;
        const backgroundUrl = buttonBackgrounds[buttonSize];
        if (backgroundUrl) {
          filterOption.style.backgroundImage = `url('${backgroundUrl}')`;
          filterOption.style.opacity = '0.5';
        }
      }
    };

    const mouseoutHandler = function(e) {
      const filterOption = e.target.closest('.filter-option');
      if (filterOption && !filterOption.classList.contains('selected')) {
        filterOption.style.backgroundImage = '';
        filterOption.style.opacity = '1';
      }
    };

    // Attach to map container
    mapContainer.addEventListener('click', clickHandler);
    mapContainer.addEventListener('mouseover', mouseoverHandler);
    mapContainer.addEventListener('mouseout', mouseoutHandler);

    console.log('‚úÖ Events attached to map container');
  }

  // Cleanup is handled automatically when page changes with transition:persist="false"


  
  // Cleanup function to properly remove existing map
  function cleanupMap() {
    if (window.wavmapInstance) {
      try {
        window.wavmapInstance.remove();
      } catch (e) {
      }
      window.wavmapInstance = null;
    }
  }
  
  async function initializeMap() {
    const mapContainer = document.getElementById('wavmap');

    if (!mapContainer) {
      return;
    }

    // Always cleanup existing map first
    cleanupMap();

    // Ensure container is completely empty for Mapbox
    mapContainer.innerHTML = '';
    console.log('üßπ Map container cleared completely');
    
    // Wait for Mapbox GL to load with retry mechanism
    let attempts = 0;
    const maxAttempts = 10;
    
    while (typeof mapboxgl === 'undefined' && attempts < maxAttempts) {
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    
    // Check if Mapbox GL is available
    if (typeof mapboxgl === 'undefined') {
      console.error('üó∫Ô∏è Mapbox GL JS not loaded after', maxAttempts, 'attempts');
      return;
    }
    
    // Use token from environment variables
    mapboxgl.accessToken = mapboxToken;
    
    try {

      // Extended Europe bounds to include Iceland and Tunisia
      const europeBounds = [
          [ -25, 30 ], // Sud-ouest : Inclut la Tunisie et l'Atlantique
          [ 45, 72 ]   // Nord-est : Inclut l'Islande et la Scandinavie
      ];

      // Responsive center and zoom for mobile
      const isMobile = window.innerWidth < 768;
      const initialCenter = isMobile ? [10, 50] : [10, 54]; // Center adjusted for mobile
      const initialZoom = isMobile ? 3.2 : 3.8; // Zoom adjusted to show full extent

      const map = new mapboxgl.Map({
        container: 'wavmap',
        style: 'mapbox://styles/mapbox/satellite-v9',
        center: initialCenter,
        zoom: initialZoom,
        maxBounds: europeBounds,
        minZoom: 3,
        maxZoom: 18
      });

      // Apply inverted grayscale filter to satellite imagery ONLY (not to our custom layers)
      // This will make the sea white and continents black
      map.on('style.load', () => {
        // Get all layers from the style
        const layers = map.getStyle().layers;

        // Apply filter to all existing raster layers (satellite imagery)
        layers.forEach((layer) => {
          if (layer.type === 'raster') {
            // Make it grayscale
            map.setPaintProperty(layer.id, 'raster-saturation', -1);

            // Invert the colors by swapping min and max brightness
            // This makes dark areas (sea) become light (white)
            // and light areas (land) become dark (black)
            map.setPaintProperty(layer.id, 'raster-brightness-min', 1);
            map.setPaintProperty(layer.id, 'raster-brightness-max', 0);

            // Increase contrast for sharper distinction
            map.setPaintProperty(layer.id, 'raster-contrast', 0.2);
          }
        });
      });
      
      // Store global instance
      window.wavmapInstance = map;
      
      // Add navigation controls
      map.addControl(new mapboxgl.NavigationControl());
      
      // Add fullscreen control  
      map.addControl(new mapboxgl.FullscreenControl());
      
      // Load and add real artist data when map is ready
      map.on('load', async function() {
        // Log current map state
        console.log('üó∫Ô∏è Map loaded!');
        console.log('üìç Initial center:', map.getCenter());
        console.log('üîç Initial zoom:', map.getZoom());

        // Fetch approved artists from API
        const artists = await loadApprovedArtists();

        if (artists.length === 0) {
          console.log('‚ÑπÔ∏è No artists to display on map');
          return;
        }

        console.log(`üéµ Loaded ${artists.length} artists for clustering`);
        artists.forEach((artist, i) => {
          if (i < 3) { // Log first 3 for debugging
            console.log(`Artist ${i + 1}:`, {
              name: artist.artistName,
              coords: [artist.longitude, artist.latitude],
              city: artist.city
            });
          }
        });

        // Store artists globally
        allArtists = artists;
        filteredArtists = artists; // Initialize filtered artists

        // Initialize country mapping first, then populate filter options
        initCountryMapping();

        // Populate dynamic filter options with a small delay to ensure DOM is ready
        setTimeout(() => {
          populateFilterOptions(artists);
        }, 100);

        // Log that filter options are ready
        console.log('‚úÖ Filter options populated and ready for interaction');

        // Convert artist data to GeoJSON format with null checks
        const geojsonData = {
          type: 'FeatureCollection',
          features: artists
            .filter(artist => artist.longitude != null && artist.latitude != null)
            .map(artist => ({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [
                  parseFloat(artist.longitude) || 0,
                  parseFloat(artist.latitude) || 0
                ]
              },
              properties: {
                id: artist.id || '',
                artistName: artist.artistName || 'Unknown Artist',
                city: artist.city || 'Unknown City',
                country: artist.country || 'Unknown Country',
                activities: Array.isArray(artist.activities) ? artist.activities.join(', ') : '',
                genres: Array.isArray(artist.genres) ? artist.genres.join(', ') : ''
              }
            }))
        };

        // Add cluster source with proper configuration
        console.log('üó∫Ô∏è Adding points source with', geojsonData.features.length, 'features');
        map.addSource('points', {
          type: 'geojson',
          data: geojsonData,
          cluster: true,
          clusterMaxZoom: 10,   // Stop clustering at zoom level 5 (when more zoomed in, show individual points)
          clusterRadius: 50,   // Radius in pixels to cluster points
          clusterProperties: {
            // Store full artist data in cluster for later use
            'artistIds': ['concat', ['concat', ['get', 'id'], ',']]
          }
        });

        // Impl√©mentation du clustering selon le tutoriel officiel Mapbox
        console.log('‚úÖ Points source added, adding cluster layers');

        // Create SVG icons with radial gradients for clusters
        function createClusterIcon(pointCount) {
          let gradient, size;

          if (pointCount >= 2 && pointCount <= 3) {
            size = 60;
            gradient = `
              <radialGradient id="grad-small-${pointCount}" cx="50%" cy="50%" r="50%">
                <stop offset="0%" style="stop-color:#E92C0F;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#E9930F;stop-opacity:1" />
              </radialGradient>
            `;
          } else if (pointCount >= 4 && pointCount <= 5) {
            size = 80;
            gradient = `
              <radialGradient id="grad-medium-${pointCount}" cx="50%" cy="50%" r="50%">
                <stop offset="0%" style="stop-color:#E92C0F;stop-opacity:1" />
                <stop offset="50%" style="stop-color:#E9930F;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#3E44E6;stop-opacity:1" />
              </radialGradient>
            `;
          } else {
            size = 100;
            gradient = `
              <radialGradient id="grad-large-${pointCount}" cx="50%" cy="50%" r="50%">
                <stop offset="0%" style="stop-color:#E92C0F;stop-opacity:1" />
                <stop offset="30%" style="stop-color:#E9930F;stop-opacity:1" />
                <stop offset="70%" style="stop-color:#3E44E6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#8FD116;stop-opacity:1" />
              </radialGradient>
            `;
          }

          const gradientId = pointCount <= 3 ? `grad-small-${pointCount}` : pointCount <= 5 ? `grad-medium-${pointCount}` : `grad-large-${pointCount}`;

          const svg = `
            <svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg">
              <defs>${gradient}</defs>
              <circle cx="${size/2}" cy="${size/2}" r="${size/2 - 2}" fill="url(#${gradientId})" stroke="white" stroke-width="0"/>
              <text x="50%" y="50%" text-anchor="middle" dy=".3em" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="white">${pointCount}</text>
            </svg>
          `;

          return `data:image/svg+xml;base64,${btoa(svg)}`;
        }

        // Load all cluster icons before adding layers
        const clusterIconPromises = [];
        for (let i = 2; i <= 100; i++) {
          const iconUrl = createClusterIcon(i);
          const iconName = `cluster-${i}`;

          const promise = new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
              if (!map.hasImage(iconName)) {
                map.addImage(iconName, img);
              }
              resolve();
            };
            img.onerror = resolve; // Continue even if image fails
            img.src = iconUrl;
          });

          clusterIconPromises.push(promise);
        }

        // Wait for all icons to load
        Promise.all(clusterIconPromises).then(() => {
          console.log('‚úÖ All cluster icons loaded');

          // Add cluster symbol layer with gradient icons
          map.addLayer({
            id: 'clusters',
            type: 'symbol',
            source: 'points',
            filter: ['has', 'point_count'],
            layout: {
              'icon-image': [
                'concat',
                'cluster-',
                ['get', 'point_count']
              ],
              'icon-size': 1,
              'icon-allow-overlap': true
            }
          });
        });

        // Add individual points (red circles)
        map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'points',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': '#E92C0F',
            'circle-radius': 8,
            'circle-stroke-width': 0,
            'circle-stroke-color': '#fff'
          }
        });

        // Add click handlers for clusters (zoom in on click)
        map.on('click', 'clusters', (e) => {
          const features = map.queryRenderedFeatures(e.point, {
            layers: ['clusters']
          });

          if (!features.length) return;

          const clusterId = features[0].properties.cluster_id;
          map.getSource('points').getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err) return;

            map.easeTo({
              center: features[0].geometry.coordinates,
              zoom: zoom
            });
          });
        });

        // Add click handlers for individual points (show artist detail)
        map.on('click', 'unclustered-point', (e) => {
          const features = map.queryRenderedFeatures(e.point, {
            layers: ['unclustered-point']
          });

          if (!features.length) return;

          const properties = features[0].properties;
          const fullArtist = allArtists.find(a => a.id === properties.id);

          if (fullArtist) {
            showArtistDetail(fullArtist);
          }
        });

        // Change cursor on hover
        map.on('mouseenter', 'clusters', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'clusters', () => {
          map.getCanvas().style.cursor = '';
        });
        map.on('mouseenter', 'unclustered-point', () => {
          map.getCanvas().style.cursor = 'pointer';
        });
        map.on('mouseleave', 'unclustered-point', () => {
          map.getCanvas().style.cursor = '';
        });

        // Add click handler to get coordinates easily
        map.on('click', function(e) {
          const coords = e.lngLat;
          console.log('üéØ Clicked coordinates:');
          console.log(`   Longitude: ${coords.lng.toFixed(4)}`);
          console.log(`   Latitude: ${coords.lat.toFixed(4)}`);
          console.log(`   Array format: [${coords.lng.toFixed(4)}, ${coords.lat.toFixed(4)}]`);
        });

        // Dispatch event when map is fully ready
        console.log('üéâ Map fully loaded and ready');
        window.dispatchEvent(new CustomEvent('mapReady'));
      });

      map.on('error', function(e) {
        console.error('üó∫Ô∏è Mapbox error:', e);
      });
      
    } catch (error) {
      console.error('üó∫Ô∏è Error initializing Mapbox:', error);
    }
  }
  

  // Simple initialization for isolated map
  function initializeApp() {
    console.log('üöÄ Map initialization started...');

    initializeMap().then(() => {
      initializeFilterButtonHover();
      attachSimpleEvents();
      console.log('‚úÖ Map initialization complete');
    }).catch(error => {
      console.error('üó∫Ô∏è Map initialization failed:', error);
    });
  }

  // Simple lifecycle - map is isolated with transition:persist="false"
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeApp);
  } else {
    initializeApp();
  }
  
</script>

<style>
  .map-container {
    width: 100%;
    margin: 0 auto;
    display: flex;
    color: black;
    padding: 1rem;
    height: calc(100vh - var(--navbar-height, 80px));
    box-sizing: border-box;
  }

  .artist-content {
    height: 100%;
    width: 100%;
    background: linear-gradient(
        to right, /* Direction chang√©e vers la droite */
        #8FD116,
        #3E44E6 50%,
        #E9930F 80%,
        #E92C0F 100%
      );
  }


  /* Artist name */
  .artist-name {
    font-size: 24px;
    font-weight: 900;
    text-transform: uppercase;
    margin-bottom: 0.5rem;
  }

  /* Pronouns */
  .artist-pronouns-container {
    text-align: center;
    margin-bottom: 1rem;
  }

  .artist-pronouns {
    font-size: 0.9rem;
    font-weight: 600;
    color: #555;
    margin: 0.25rem 0;
    font-style: italic;
  }

  /* Artist location */
  .artist-location {
    font-size: 1.2rem;
    font-weight: 800;
    text-align: center;
    margin: 0 0 1.5rem 0;
    color: #000;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* Artist bio */
  .artist-bio {
    margin: 1.5rem 0;
    text-align: justify;
    line-height: 1.6;
  }

  .artist-bio p {
    margin: 0;
    font-size: 0.95rem;
    color: #000;
    font-weight: 700;
  }

  /* Separator line */
  .separator-line {
    margin: 2rem 0;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .separator-line img {
    width: 100%;
    height: auto;
    max-width: 400px;
  }

  .separator-bottom img {
    transform: rotate(180deg);
  }

  /* Social media links */
  .social-media-links {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 2rem 0;
    font-size: 1.5rem;
    font-weight: 700;
    color: #000;
    letter-spacing: 2px;
  }

  .social-link {
    cursor: pointer;
    transition: color 0.2s ease;
  }

  .social-link:hover:not(.disabled) {
    color: #000;
  }

  .social-link.disabled {
    color: #ccc !important;
    cursor: default !important;
    opacity: 0.5;
  }

  .separator {
    margin: 0 1rem;
    font-size: 1.2rem;
  }

  /* Tags lines */
  .tags-line {
    margin: 1rem 0;
    text-align: center;
  }

  .tags-inline {
    display: inline-flex;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    font-weight: 700;
    gap: 6px;
  }

  .tag-inline {
    font-size: 0.9rem;
    color: #000;
    padding: 0;
    margin: 0;
  }

  .tag-separator {
    margin: 0 0.5rem;
    font-size: 0.9rem;
    color: #000;
    font-weight: 900;
  }

  /* Section titles */
  .section-title {
    font-size: 1.1rem;
    font-weight: 800;
    color: #000;
    text-transform: uppercase;
    margin: 1.5rem 0 0.8rem 0;
    letter-spacing: 0.5px;
  }

  /* Social topics */
  .social-topics-container, .themes-container, .club-politics-container {
    margin: 1.5rem 0;
    padding: 1rem;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 8px;
    display: block !important;
  }

  .social-topics-container.hidden, .themes-container.hidden, .club-politics-container.hidden {
    display: none !important;
  }

  .topics-content {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .topic-tag {
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 0.3rem 0.6rem;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: capitalize;
  }

  /* Themes and club politics content */
  .themes-content, .club-politics-content {
    font-size: 0.95rem;
    line-height: 1.6;
    color: #333;
    margin: 0;
    text-align: justify;
  }

  .filters-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    text-align: left;
    align-items: flex-start;
    width: 30%;
    flex-shrink: 0;
    height: 100%;
    overflow-y: auto;
    padding-left: 1rem;
  }

  .filters-content {
    padding-left: 2rem;
    height: 100%;
    overflow-y: auto;
  }

  /* Close hover button */
  .close-hover-btn {
    position: relative;
    cursor: pointer;
    margin: 0 auto 1rem auto;
    width: fit-content;
    display: flex;
    justify-content: center;
  }

  .close-btn-normal,
  .close-btn-hover {
    height: 30px;
    width: auto;
    display: block;
  }

  .close-btn-normal {
    transition: opacity 0.2s ease;
  }

  .close-btn-hover {
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  .close-hover-btn:hover .close-btn-normal {
    opacity: 0;
  }

  .close-hover-btn:hover .close-btn-hover {
    opacity: 1;
  }

  .artist-header {
    gap: 1rem;
    display: flex;
    flex-direction: column;
  }

  .artist-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0.5rem 0 0.5rem 0;
  }

  .artist-info {
    margin-bottom: 1.5rem;
  }

  .info-section {
    margin-bottom: 1.25rem;
  }

  .info-section h3 {
    font-size: 1rem;
    font-weight: 600;
    color: #374151;
    margin: 0 0 0.5rem 0;
  }

  .info-section p {
    font-size: 0.9rem;
    color: #6b7280;
    margin: 0;
    line-height: 1.5;
  }

  .social-links {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .social-links a {
    display: inline-block;
    padding: 0.375rem 0.75rem;
    background: #f3f4f6;
    color: #4b5563;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .social-links a:hover {
    background: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  .artist-actions {
    padding-top: 1rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  .view-profile-btn {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  .view-profile-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
  }

  .close-panel-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    width: 32px;
    height: 32px;
    border: none;
    background: rgba(0, 0, 0, 0.1);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    color: #666;
    transition: all 0.2s ease;
    z-index: 11;
  }

  .close-panel-btn:hover {
    background: rgba(0, 0, 0, 0.2);
    color: #000;
  }

  .artist-detail {
    padding: 2rem;
    padding-top: 3rem;
  }

  .artist-header {
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid #e5e7eb;
  }

  .artist-header h2 {
    font-size: 1.5rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 0.5rem 0;
  }

  .artist-info {
    margin-bottom: 1.5rem;
  }

  .info-section {
    margin-bottom: 1.25rem;
  }

  .info-section h3 {
    font-size: 1rem;
    font-weight: 600;
    color: #374151;
    margin: 0 0 0.5rem 0;
  }

  .info-section p {
    font-size: 0.9rem;
    color: #6b7280;
    margin: 0;
    line-height: 1.5;
  }

  .social-links {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .social-links a {
    display: inline-block;
    padding: 0.375rem 0.75rem;
    background: #f3f4f6;
    color: #4b5563;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  .social-links a:hover {
    background: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  .artist-actions {
    padding-top: 1rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  :global(.artist-detail .view-profile-btn) {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s ease;
  }

  :global(.artist-detail .view-profile-btn:hover) {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
  }

  .map-container h2 {
    font-size: 2rem;
    font-weight: 700;
    color: #1f2937;
    margin: 0 0 1rem 0;
    text-align: center;
    background-clip: text;
    -webkit-background-clip: text;
  }

  .shuffle {
    position: absolute;
    left: 1rem;
    bottom: 1rem;
    width: 150px;
    z-index: 3;
  }

  .filter img {
    height: 50px;
  }

  .filter-button-image {
    transition: opacity 0.2s ease, transform 0.2s ease;
  }

  .filter-hover-btn:hover .filter-button-image {
    transform: scale(1.05);
  }

  .filter-hover-btn:active .filter-button-image {
    transform: scale(0.95);
  }

  .filter-wrapper {
    position: relative;
    margin-bottom: 0.5rem;
  }

  .filter-options.hidden {
    display: none;
  }

  .map-wrapper {
    flex: 1;
    position: relative;
    min-width: 0;
  }

  .map {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  /* Hide "Improve this map" link from attribution */
  :global(.mapbox-improve-map) {
    display: none !important;
  }

  /*
   * TEMPORARILY DISABLED: The CSS filter affects ALL layers rendered on the canvas,
   * including our native cluster layers. We'll need a different approach.
   *
   * Option 1: Use a custom Mapbox style with grayscale satellite imagery
   * Option 2: Use a filter layer approach
   * Option 3: Keep HTML markers (but with performance issues)
   *
   * For now, let's test without the filter to verify the clustering works perfectly.
   */

  /*
  .map :global(.mapboxgl-canvas-container canvas) {
    filter:
      grayscale(100%)
      contrast(100%)
      saturate(220%)
      brightness(220%)
      hue-rotate(180deg);
  }
  */

  .map .mapboxgl-ctrl {
    filter: none;
  }

  /* Custom popup styles */
  :global(.mapboxgl-popup-content) {
    border-radius: 0.5rem;
    box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  }

  :global(.artist-popup h3) {
    margin: 0 0 0.5rem 0;
    color: #1f2937;
    font-size: 1.1rem;
    font-weight: 600;
  }

  :global(.artist-popup p) {
    margin: 0.25rem 0;
    font-size: 0.9rem;
    color: #6b7280;
  }

  :global(.artist-popup strong) {
    color: #374151;
  }

  :global(.artist-popup .social-links) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
  }

  :global(.artist-popup .social-links a) {
    display: inline-block;
    margin: 0 0.5rem 0.25rem 0;
    color: #6366f1;
    text-decoration: none;
    font-size: 0.8rem;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    background-color: #f8f9ff;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .social-links a:hover) {
    background-color: #6366f1;
    color: white;
    transform: translateY(-1px);
  }

  :global(.artist-popup .popup-actions) {
    margin-top: 0.75rem;
    padding-top: 0.5rem;
    border-top: 1px solid #e5e7eb;
    text-align: center;
  }

  :global(.artist-popup .view-profile-btn) {
    display: inline-block;
    background: linear-gradient(135deg, #6366f1, #8b5cf6);
    color: white;
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.2s ease;
  }

  :global(.artist-popup .view-profile-btn:hover) {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
  }

  /* Filter options styling */
  :global(.filter-option) {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.375rem 1.5rem;
    background: transparent;
    color: black;
    text-decoration: none;
    border-radius: 0.375rem;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0.125rem;
    border: 2px solid transparent;
    position: relative;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    height: 38px;
    min-height: 38px;
    min-width: fit-content;
  }

  :global(.filter-option:hover) {
    /* Remove the transform to avoid size changes */
  }

  /* Selected state with SVG border and black fill */
  :global(.filter-option.selected) {
    color: white !important;
    font-weight: 700 !important;
    text-shadow: none !important;
    opacity: 1 !important;
  }

  :global(.filter-option.selected:hover) {
    filter: brightness(0.85) !important;
  }

  /* Clear filter button */
  .clear-filter-btn {
    display: inline-block;
    padding: 0.5rem 1rem;
    background: #ef4444;
    color: white;
    border: none;
    border-radius: 0.375rem;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0.25rem 0;
  }

  .clear-filter-btn:hover {
    background: #dc2626;
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(239, 68, 68, 0.3);
  }

  .clear-filter-btn.hidden {
    display: none;
  }

  /* Global Clear All Filters Button */
  .clear-all-filters-btn {
    display: inline-block;
    padding: 0;
    background: none;
    color: red;
    border: none;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 1rem 0;
    text-decoration: underline;
  }

  .clear-all-filters-btn:hover {
    color: darkred;
    text-decoration: underline;
  }

  .clear-all-filters-btn.hidden {
    display: none;
  }

  /* Dynamic filter options container */
  .dynamic-filter-options {
    width: 100%;
  }

  /* City filter specific styling */
  .city-filter {
    min-width: 60px;
    text-align: center;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .map-container {
      flex-direction: column;
      padding: 0.5rem;
      height: calc(100vh - var(--navbar-height, 80px));
    }

    .map-wrapper {
      width: 100%;
      height: 60vh; /* Map takes 60% of viewport height */
      margin-bottom: 1rem;
    }

    .map {
      height: 100%;
    }

    .filters-container {
      width: 100%;
      height: calc(40vh - 2rem); /* Filters take remaining space */
      flex-direction: row;
      flex-wrap: wrap;
      gap: 0.5rem;
      overflow-y: auto;
    }

    .filters-content {
      padding-left: 0;
      height: auto;
      width: 100%;
    }

    .filter-wrapper {
      margin-bottom: 1rem;
    }

    .filter img {
      height: 40px;
    }

    .filter-option {
      font-size: 0.75rem;
      padding: 0.25rem 0.75rem;
      height: 32px;
      min-height: 32px;
    }

    .clear-filter-btn {
      font-size: 0.75rem;
      padding: 0.375rem 0.75rem;
    }

    .clear-all-filters-btn {
      font-size: 0.8rem;
      margin: 0.5rem 0;
    }

    .shuffle {
      left: 0.5rem;
      bottom: 0.5rem;
      width: 102px; /* 15% smaller than 120px */
    }

    .shuffle img {
      width: 100%;
      height: auto;
    }

    /* Full screen modal for artist content on mobile */
    .artist-content {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 1000;
      margin: 0;
      background: linear-gradient(
        to right,
        #8FD116,
        #3E44E6 50%,
        #E9930F 80%,
        #E92C0F 100%
      );
    }

    .artist-content > div {
      height: 100vh !important;
      margin: 0 !important;
      padding: 1rem;
      overflow-y: auto;
      box-sizing: border-box;
    }

    .artist-name {
      font-size: 1.8rem;
      margin-bottom: 0.75rem;
    }

    .artist-location {
      font-size: 1rem;
      margin-bottom: 1rem;
    }

    .artist-bio p {
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .social-media-links {
      font-size: 1.2rem;
      margin: 1.5rem 0;
    }

    .section-title {
      font-size: 1rem;
      margin: 1rem 0 0.5rem 0;
    }

    .topic-tag {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }

    .themes-content, .club-politics-content {
      font-size: 0.85rem;
      line-height: 1.5;
    }

    .close-hover-btn {
      margin-bottom: 0.5rem;
    }
  }

  /* Small mobile screens */
  @media (max-width: 480px) {
    .map-container {
      padding: 0.25rem;
    }

    .map-wrapper {
      height: 50vh; /* Smaller map on very small screens */
    }

    .filters-container {
      height: calc(50vh - 1rem);
    }

    .filter-wrapper {
      flex: 1 1 auto;
      min-width: 0;
    }

    .filter-options {
      flex-wrap: wrap;
      gap: 0.25rem;
    }

    .filter-option {
      font-size: 0.7rem;
      padding: 0.2rem 0.5rem;
      height: 28px;
      min-height: 28px;
      margin: 0.1rem;
    }

    .artist-name {
      font-size: 1.5rem;
    }

    .artist-location {
      font-size: 0.9rem;
    }

    .social-media-links {
      font-size: 1rem;
    }
  }
</style>

<!-- Import Mapbox CSS and JS -->
<link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>